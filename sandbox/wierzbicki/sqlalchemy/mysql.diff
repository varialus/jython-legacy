Index: mysql.py
===================================================================
--- mysql.py	(revision 2938)
+++ mysql.py	(working copy)
@@ -953,45 +953,19 @@
         ansisql.ANSIDialect.__init__(self, default_paramstyle='format', **kwargs)
 
     def dbapi(cls):
-        import MySQLdb as mysql
+        import com.ziclix.python.sql.zxJDBC as mysql
         return mysql
     dbapi = classmethod(dbapi)
     
     def create_connect_args(self, url):
         opts = url.translate_connect_args(['host', 'db', 'user', 'passwd', 'port'])
-        opts.update(url.query)
+        if opts.get('host') == None:
+            opts['host'] = 'localhost'
+        if opts.get('port') == None:
+            opts['port'] = '3306'
+        args = ['jdbc:mysql://%(host)s:%(port)s/%(db)s' % opts, opts['user'], opts['passwd'], 'org.gjt.mm.mysql.Driver']
+        return [args, {}]
 
-        util.coerce_kw_type(opts, 'compress', bool)
-        util.coerce_kw_type(opts, 'connect_timeout', int)
-        util.coerce_kw_type(opts, 'client_flag', int)
-        util.coerce_kw_type(opts, 'local_infile', int)
-        # note: these two could break SA Unicode type
-        util.coerce_kw_type(opts, 'use_unicode', bool)   
-        util.coerce_kw_type(opts, 'charset', str)
-        # TODO: cursorclass and conv:  support via query string or punt?
-        
-        # ssl
-        ssl = {}
-        for key in ['ssl_ca', 'ssl_key', 'ssl_cert', 'ssl_capath', 'ssl_cipher']:
-            if key in opts:
-                ssl[key[4:]] = opts[key]
-                util.coerce_kw_type(ssl, key[4:], str)
-                del opts[key]
-        if len(ssl):
-            opts['ssl'] = ssl
-        
-        # FOUND_ROWS must be set in CLIENT_FLAGS for to enable
-        # supports_sane_rowcount.
-        client_flag = opts.get('client_flag', 0)
-        if self.dbapi is not None:
-            try:
-                import MySQLdb.constants.CLIENT as CLIENT_FLAGS
-                client_flag |= CLIENT_FLAGS.FOUND_ROWS
-            except:
-                pass
-            opts['client_flag'] = client_flag
-        return [[], opts]
-
     def create_execution_context(self, *args, **kwargs):
         return MySQLExecutionContext(self, *args, **kwargs)
 
@@ -1083,8 +1057,7 @@
             table.metadata.tables[table.name]= table
 
         try:
-            rp = connection.execute("describe " + self._escape_table_name(table),
-                                   {})
+            rp = connection.execute("describe " + self._escape_table_name(table))
         except:
             raise exceptions.NoSuchTableError(table.fullname)
 
@@ -1093,7 +1066,7 @@
                    (row[0], row[1], row[2] == 'YES', row[3] == 'PRI', row[4])
 
             # leave column names as unicode
-            name = name.decode(decode_from)
+            ###name = name.decode(decode_from)
 
             match = re.match(r'(\w+)(\(.*?\))?\s*(\w+)?\s*(\w+)?', type)
             col_type = match.group(1)
@@ -1128,13 +1101,13 @@
                                                    nullable=nullable,
                                                    )))
 
-        tabletype = self.moretableinfo(connection, table, decode_from)
+        tabletype = self.moretableinfo(connection, table)###, decode_from)
         table.kwargs['mysql_engine'] = tabletype
 
     def moretableinfo(self, connection, table, charset=None):
         """SHOW CREATE TABLE to get foreign key/table options."""
 
-        rp = connection.execute("SHOW CREATE TABLE " + self._escape_table_name(table), {})
+        rp = connection.execute("SHOW CREATE TABLE " + self._escape_table_name(table))###, {})
         row = _compat_fetch(rp, one=True, charset=charset)
         if not row:
             raise exceptions.NoSuchTableError(table.fullname)
