Index: mysql.py
===================================================================
--- mysql.py	(revision 2938)
+++ mysql.py	(working copy)
@@ -4,7 +4,7 @@
 # This module is part of SQLAlchemy and is released under
 # the MIT License: http://www.opensource.org/licenses/mit-license.php
 
-import sys, StringIO, string, types, re, datetime, inspect, warnings
+import sys, StringIO, string, types, sre, datetime, inspect, warnings
 
 from sqlalchemy import sql,engine,schema,ansisql
 from sqlalchemy.engine import default
@@ -953,45 +953,19 @@
         ansisql.ANSIDialect.__init__(self, default_paramstyle='format', **kwargs)
 
     def dbapi(cls):
-        import MySQLdb as mysql
+        import com.ziclix.python.sql.zxJDBC as mysql
         return mysql
     dbapi = classmethod(dbapi)
     
     def create_connect_args(self, url):
         opts = url.translate_connect_args(['host', 'db', 'user', 'passwd', 'port'])
-        opts.update(url.query)
+        if opts.get('host') == None:
+            opts['host'] = 'localhost'
+        if opts.get('port') == None:
+            opts['port'] = '3306'
+        args = ['jdbc:mysql://%(host)s:%(port)s/%(db)s' % opts, opts['user'], opts['passwd'], 'org.gjt.mm.mysql.Driver']
+        return [args, {}]
 
-        util.coerce_kw_type(opts, 'compress', bool)
-        util.coerce_kw_type(opts, 'connect_timeout', int)
-        util.coerce_kw_type(opts, 'client_flag', int)
-        util.coerce_kw_type(opts, 'local_infile', int)
-        # note: these two could break SA Unicode type
-        util.coerce_kw_type(opts, 'use_unicode', bool)   
-        util.coerce_kw_type(opts, 'charset', str)
-        # TODO: cursorclass and conv:  support via query string or punt?
-        
-        # ssl
-        ssl = {}
-        for key in ['ssl_ca', 'ssl_key', 'ssl_cert', 'ssl_capath', 'ssl_cipher']:
-            if key in opts:
-                ssl[key[4:]] = opts[key]
-                util.coerce_kw_type(ssl, key[4:], str)
-                del opts[key]
-        if len(ssl):
-            opts['ssl'] = ssl
-        
-        # FOUND_ROWS must be set in CLIENT_FLAGS for to enable
-        # supports_sane_rowcount.
-        client_flag = opts.get('client_flag', 0)
-        if self.dbapi is not None:
-            try:
-                import MySQLdb.constants.CLIENT as CLIENT_FLAGS
-                client_flag |= CLIENT_FLAGS.FOUND_ROWS
-            except:
-                pass
-            opts['client_flag'] = client_flag
-        return [[], opts]
-
     def create_execution_context(self, *args, **kwargs):
         return MySQLExecutionContext(self, *args, **kwargs)
 
@@ -1083,8 +1057,7 @@
             table.metadata.tables[table.name]= table
 
         try:
-            rp = connection.execute("describe " + self._escape_table_name(table),
-                                   {})
+            rp = connection.execute("describe " + self._escape_table_name(table))
         except:
             raise exceptions.NoSuchTableError(table.fullname)
 
@@ -1093,9 +1066,9 @@
                    (row[0], row[1], row[2] == 'YES', row[3] == 'PRI', row[4])
 
             # leave column names as unicode
-            name = name.decode(decode_from)
+            ###name = name.decode(decode_from)
 
-            match = re.match(r'(\w+)(\(.*?\))?\s*(\w+)?\s*(\w+)?', type)
+            match = sre.match(r'(\w+)(\(.*?\))?\s*(\w+)?\s*(\w+)?', type)
             col_type = match.group(1)
             args = match.group(2)
             extra_1 = match.group(3)
@@ -1115,7 +1088,7 @@
                     argslist = args.split(',')
                     coltype = coltype(*argslist, **kw)
                 else:
-                    argslist = re.findall(r'(\d+)', args)
+                    argslist = sre.findall(r'(\d+)', args)
                     coltype = coltype(*[int(a) for a in argslist], **kw)
 
             colargs= []
@@ -1128,30 +1101,30 @@
                                                    nullable=nullable,
                                                    )))
 
-        tabletype = self.moretableinfo(connection, table, decode_from)
+        tabletype = self.moretableinfo(connection, table)###, decode_from)
         table.kwargs['mysql_engine'] = tabletype
 
     def moretableinfo(self, connection, table, charset=None):
         """SHOW CREATE TABLE to get foreign key/table options."""
 
-        rp = connection.execute("SHOW CREATE TABLE " + self._escape_table_name(table), {})
+        rp = connection.execute("SHOW CREATE TABLE " + self._escape_table_name(table))###, {})
         row = _compat_fetch(rp, one=True, charset=charset)
         if not row:
             raise exceptions.NoSuchTableError(table.fullname)
         desc = row[1].strip()
 
         tabletype = ''
-        lastparen = re.search(r'\)[^\)]*\Z', desc)
+        lastparen = sre.search(r'\)[^\)]*\Z', desc)
         if lastparen:
-            match = re.search(r'\b(?:TYPE|ENGINE)=(?P<ttype>.+)\b', desc[lastparen.start():], re.I)
+            match = sre.search(r'\b(?:TYPE|ENGINE)=(?P<ttype>.+)\b', desc[lastparen.start():], sre.I)
             if match:
                 tabletype = match.group('ttype')
 
         # \x27 == ' (single quote)  (avoid xemacs syntax highlighting issue)
         fkpat = r'''CONSTRAINT [`"\x27](?P<name>.+?)[`"\x27] FOREIGN KEY \((?P<columns>.+?)\) REFERENCES [`"\x27](?P<reftable>.+?)[`"\x27] \((?P<refcols>.+?)\)'''
-        for match in re.finditer(fkpat, desc):
-            columns = re.findall(r'''[`"\x27](.+?)[`"\x27]''', match.group('columns'))
-            refcols = [match.group('reftable') + "." + x for x in re.findall(r'''[`"\x27](.+?)[`"\x27]''', match.group('refcols'))]
+        for match in sre.finditer(fkpat, desc):
+            columns = sre.findall(r'''[`"\x27](.+?)[`"\x27]''', match.group('columns'))
+            refcols = [match.group('reftable') + "." + x for x in sre.findall(r'''[`"\x27](.+?)[`"\x27]''', match.group('refcols'))]
             schema.Table(match.group('reftable'), table.metadata, autoload=True, autoload_with=connection)
             constraint = schema.ForeignKeyConstraint(columns, refcols, name=match.group('name'))
             table.append_constraint(constraint)
