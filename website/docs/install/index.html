<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Installing Python Modules &mdash; Jython v2.5.0 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li><a href="../index.html">Jython v2.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Installing Python Modules</a><ul>
<li><a class="reference external" href="#abstract">Abstract</a><ul>
<li><a class="reference external" href="#introduction">Introduction</a><ul>
<li><a class="reference external" href="#best-case-trivial-installation">Best case: trivial installation</a></li>
<li><a class="reference external" href="#the-new-standard-distutils">The new standard: Distutils</a></li>
</ul>
</li>
<li><a class="reference external" href="#standard-build-and-install">Standard Build and Install</a><ul>
<li><a class="reference external" href="#platform-variations">Platform variations</a></li>
<li><a class="reference external" href="#splitting-the-job-up">Splitting the job up</a></li>
<li><a class="reference external" href="#how-building-works">How building works</a></li>
<li><a class="reference external" href="#how-installation-works">How installation works</a></li>
</ul>
</li>
<li><a class="reference external" href="#alternate-installation">Alternate Installation</a><ul>
<li><a class="reference external" href="#alternate-installation-the-home-scheme">Alternate installation: the home scheme</a></li>
<li><a class="reference external" href="#alternate-installation-unix-the-prefix-scheme">Alternate installation: Unix (the prefix scheme)</a></li>
<li><a class="reference external" href="#alternate-installation-windows-the-prefix-scheme">Alternate installation: Windows (the prefix scheme)</a></li>
</ul>
</li>
<li><a class="reference external" href="#custom-installation">Custom Installation</a><ul>
<li><a class="reference external" href="#modifying-python-s-search-path">Modifying Python&#8217;s Search Path</a></li>
</ul>
</li>
<li><a class="reference external" href="#distutils-configuration-files">Distutils Configuration Files</a><ul>
<li><a class="reference external" href="#location-and-names-of-config-files">Location and names of config files</a></li>
<li><a class="reference external" href="#syntax-of-config-files">Syntax of config files</a></li>
</ul>
</li>
<li><a class="reference external" href="#building-extensions-tips-and-tricks">Building Extensions: Tips and Tricks</a><ul>
<li><a class="reference external" href="#tweaking-compiler-linker-flags">Tweaking compiler/linker flags</a></li>
<li><a class="reference external" href="#using-non-microsoft-compilers-on-windows">Using non-Microsoft compilers on Windows</a><ul>
<li><a class="reference external" href="#borland-codegear-c">Borland/CodeGear C++</a></li>
<li><a class="reference external" href="#gnu-c-cygwin-mingw">GNU C / Cygwin / MinGW</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/install/index.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="installing-python-modules">
<h1>Installing Python Modules<a class="headerlink" href="#installing-python-modules" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>Author:</dt>
<dd>Greg Ward</dd>
<dt>Release:</dt>
<dd>2.6</dd>
<dt>Date:</dt>
<dd>July 31, 2009</dd>
</dl>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This document describes the Python Distribution Utilities
(&#8220;Distutils&#8221;) from the end-user&#8217;s point-of-view, describing how to
extend the capabilities of a standard Python installation by building
and installing third-party Python modules and extensions.</p>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>Although Python&#8217;s extensive standard library covers many programming
needs, there often comes a time when you need to add some new
functionality to your Python installation in the form of third-party
modules.  This might be necessary to support your own programming, or
to support an application that you want to use and that happens to be
written in Python.</p>
<p>In the past, there has been little support for adding third-party
modules to an existing Python installation.  With the introduction of
the Python Distribution Utilities (Distutils for short) in Python 2.0,
this changed.</p>
<p>This document is aimed primarily at the people who need to install
third-party Python modules: end-users and system administrators who
just need to get some Python application running, and existing Python
programmers who want to add some new goodies to their toolbox.  You
don&#8217;t need to know Python to read this document; there will be some
brief forays into using Python&#8217;s interactive mode to explore your
installation, but that&#8217;s it.  If you&#8217;re looking for information on how
to distribute your own Python modules so that others may use them, see
the <em>Distributing Python Modules</em> manual.</p>
<div class="section" id="best-case-trivial-installation">
<h4>Best case: trivial installation<a class="headerlink" href="#best-case-trivial-installation" title="Permalink to this headline">¶</a></h4>
<p>In the best case, someone will have prepared a special version of the
module distribution you want to install that is targeted specifically
at your platform and is installed just like any other software on your
platform.  For example, the module developer might make an executable
installer available for Windows users, an RPM package for users of
RPM-based Linux systems (Red Hat, SuSE, Mandrake, and many others), a
Debian package for users of Debian-based Linux systems, and so forth.</p>
<p>In that case, you would download the installer appropriate to your
platform and do the obvious thing with it: run it if it&#8217;s an
executable installer, <tt class="docutils literal"><span class="pre">rpm</span> <span class="pre">--install</span></tt> it if it&#8217;s an RPM, etc.  You
don&#8217;t need to run Python or a setup script, you don&#8217;t need to compile
anything&#8212;you might not even need to read any instructions (although
it&#8217;s always a good idea to do so anyways).</p>
<p>Of course, things will not always be that easy.  You might be
interested in a module distribution that doesn&#8217;t have an easy-to-use
installer for your platform.  In that case, you&#8217;ll have to start with
the source distribution released by the module&#8217;s author/maintainer.
Installing from a source distribution is not too hard, as long as the
modules are packaged in the standard way.  The bulk of this document
is about building and installing modules from standard source
distributions.</p>
</div>
<div class="section" id="the-new-standard-distutils">
<h4>The new standard: Distutils<a class="headerlink" href="#the-new-standard-distutils" title="Permalink to this headline">¶</a></h4>
<p>If you download a module source distribution, you can tell pretty
quickly if it was packaged and distributed in the standard way, i.e.
using the Distutils. First, the distribution&#8217;s name and version number
will be featured prominently in the name of the downloaded archive,
e.g. <tt class="docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt> or <tt class="docutils literal"><span class="pre">widget-0.9.7.zip</span></tt>.  Next, the archive
will unpack into a similarly-named directory: <tt class="docutils literal"><span class="pre">foo-1.0</span></tt> or
<tt class="docutils literal"><span class="pre">widget-0.9.7</span></tt>.  Additionally, the distribution will contain a setup
script <tt class="docutils literal"><span class="pre">setup.py</span></tt>, and a file named <tt class="docutils literal"><span class="pre">README.txt</span></tt> or possibly just
<tt class="docutils literal"><span class="pre">README</span></tt>, which should explain that building and installing the
module distribution is a simple matter of running</p>
<blockquote>
python setup.py install</blockquote>
<p>If all these things are true, then you already know how to build and
install the modules you&#8217;ve just downloaded:  Run the command above.
Unless you need to install things in a non-standard way or customize
the build process, you don&#8217;t really need this manual.  Or rather, the
above command is everything you need to get out of this manual.</p>
</div>
</div>
<div class="section" id="standard-build-and-install">
<h3>Standard Build and Install<a class="headerlink" href="#standard-build-and-install" title="Permalink to this headline">¶</a></h3>
<p>As described in section <em>The new standard: Distutils</em>, building and
installing a module distribution using the Distutils is usually one
simple command:</p>
<blockquote>
python setup.py install</blockquote>
<p>On Unix, you&#8217;d run this command from a shell prompt; on Windows, you
have to open a command prompt window (&#8220;DOS box&#8221;) and do it there; on
Mac OS X, you open a <strong>Terminal</strong> window to get a shell prompt.</p>
<div class="section" id="platform-variations">
<h4>Platform variations<a class="headerlink" href="#platform-variations" title="Permalink to this headline">¶</a></h4>
<p>You should always run the setup command from the distribution root
directory, i.e. the top-level subdirectory that the module source
distribution unpacks into.  For example, if you&#8217;ve just downloaded a
module source distribution <tt class="docutils literal"><span class="pre">foo-1.0.tar.gz</span></tt> onto a Unix system, the
normal thing to do is:</p>
<blockquote>
gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install</blockquote>
<p>On Windows, you&#8217;d probably download <tt class="docutils literal"><span class="pre">foo-1.0.zip</span></tt>.  If you
downloaded the archive file to <tt class="docutils literal"><span class="pre">C:\Temp</span></tt>, then it would unpack into
<tt class="docutils literal"><span class="pre">C:\Temp\foo-1.0</span></tt>; you can use either a archive manipulator with a
graphical user interface (such as WinZip) or a command-line tool (such
as <strong>unzip</strong> or <strong>pkunzip</strong>) to unpack the archive.  Then, open a
command prompt window (&#8220;DOS box&#8221;), and run:</p>
<blockquote>
cd c:Tempfoo-1.0
python setup.py install</blockquote>
</div>
<div class="section" id="splitting-the-job-up">
<h4>Splitting the job up<a class="headerlink" href="#splitting-the-job-up" title="Permalink to this headline">¶</a></h4>
<p>Running <tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></tt> builds and installs all modules in one
run.  If you prefer to work incrementally&#8212;especially useful if you
want to customize the build process, or if things are going wrong&#8212;
you can use the setup script to do one thing at a time.  This is
particularly helpful when the build and install will be done by
different users&#8212;for example, you might want to build a module
distribution and hand it off to a system administrator for
installation (or do it yourself, with super-user privileges).</p>
<p>For example, you can build everything in one step, and then install
everything in a second step, by invoking the setup script twice:</p>
<blockquote>
python setup.py build
python setup.py install</blockquote>
<p>If you do this, you will notice that running the <strong>install</strong> command
first runs the <strong>build</strong> command, which&#8212;in this case&#8212;quickly
notices that it has nothing to do, since everything in the <tt class="docutils literal"><span class="pre">build</span></tt>
directory is up-to-date.</p>
<p>You may not need this ability to break things down often if all you do
is install modules downloaded off the &#8216;net, but it&#8217;s very handy for
more advanced tasks.  If you get into distributing your own Python
modules and extensions, you&#8217;ll run lots of individual Distutils
commands on their own.</p>
</div>
<div class="section" id="how-building-works">
<h4>How building works<a class="headerlink" href="#how-building-works" title="Permalink to this headline">¶</a></h4>
<p>As implied above, the <strong>build</strong> command is responsible for putting the
files to install into a <em>build directory</em>.  By default, this is
<tt class="docutils literal"><span class="pre">build</span></tt> under the distribution root; if you&#8217;re excessively concerned
with speed, or want to keep the source tree pristine, you can change
the build directory with the <em>&#8211;build-base</em> option. For example:</p>
<blockquote>
python setup.py build &#8211;build-base=/tmp/pybuild/foo-1.0</blockquote>
<p>(Or you could do this permanently with a directive in your system or
personal Distutils configuration file; see section <em>Distutils
Configuration Files</em>.)  Normally, this isn&#8217;t necessary.</p>
<p>The default layout for the build tree is as follows:</p>
<blockquote>
<p>&#8212; build/ &#8212; lib/
or
&#8212; build/ &#8212; lib.&lt;plat&gt;/</p>
<blockquote>
temp.&lt;plat&gt;/</blockquote>
</blockquote>
<p>where <tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt> expands to a brief description of the current
OS/hardware platform and Python version.  The first form, with just a
<tt class="docutils literal"><span class="pre">lib</span></tt> directory, is used for &#8220;pure module distributions&#8221;&#8212;that is,
module distributions that include only pure Python modules.  If a
module distribution contains any extensions (modules written in
C/C++), then the second form, with two <tt class="docutils literal"><span class="pre">&lt;plat&gt;</span></tt> directories, is
used.  In that case, the <tt class="docutils literal"><span class="pre">temp.*plat*</span></tt> directory holds temporary
files generated by the compile/link process that don&#8217;t actually get
installed.  In either case, the <tt class="docutils literal"><span class="pre">lib</span></tt> (or <tt class="docutils literal"><span class="pre">lib.*plat*</span></tt>) directory
contains all Python modules (pure Python and extensions) that will be
installed.</p>
<p>In the future, more directories will be added to handle Python
scripts, documentation, binary executables, and whatever else is
needed to handle the job of installing Python modules and
applications.</p>
</div>
<div class="section" id="how-installation-works">
<h4>How installation works<a class="headerlink" href="#how-installation-works" title="Permalink to this headline">¶</a></h4>
<p>After the <strong>build</strong> command runs (whether you run it explicitly, or
the <strong>install</strong> command does it for you), the work of the <strong>install</strong>
command is relatively simple: all it has to do is copy everything
under <tt class="docutils literal"><span class="pre">build/lib</span></tt> (or <tt class="docutils literal"><span class="pre">build/lib.*plat*</span></tt>) to your chosen
installation directory.</p>
<p>If you don&#8217;t choose an installation directory&#8212;i.e., if you just run
<tt class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></tt>&#8212;then the <strong>install</strong> command installs to the
standard location for third-party Python modules.  This location
varies by platform and by how you built/installed Python itself.  On
Unix (and Mac OS X, which is also Unix-based), it also depends on
whether the module distribution being installed is pure Python or
contains extensions (&#8220;non-pure&#8221;):</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="41%" />
<col width="39%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Platform</th>
<th class="head">Standard installation location</th>
<th class="head">Default value</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Unix (pure)</td>
<td><tt class="docutils literal"><span class="pre">*prefix*/lib/python*X.Y*/site-packages</span></tt></td>
<td><tt class="docutils literal"><span class="pre">/usr/local/lib/python*X.Y*/site-packages</span></tt></td>
<td><ol class="first last arabic simple">
<li></li>
</ol>
</td>
</tr>
<tr><td>Unix (non-pure)</td>
<td><tt class="docutils literal"><span class="pre">*exec-prefix*/lib/python*X.Y*/site-packages</span></tt></td>
<td><tt class="docutils literal"><span class="pre">/usr/local/lib/python*X.Y*/site-packages</span></tt></td>
<td><ol class="first last arabic simple">
<li></li>
</ol>
</td>
</tr>
<tr><td>Windows</td>
<td><tt class="docutils literal"><span class="pre">*prefix*</span></tt></td>
<td><tt class="docutils literal"><span class="pre">C:\Python</span></tt></td>
<td><ol class="first last arabic simple" start="2">
<li></li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>Most Linux distributions include Python as a standard part of the
system, so <tt class="docutils literal"><span class="pre">*prefix*</span></tt> and <tt class="docutils literal"><span class="pre">*exec-prefix*</span></tt> are usually both
<tt class="docutils literal"><span class="pre">/usr</span></tt> on Linux.  If you build Python yourself on Linux (or any
Unix-like system), the default <tt class="docutils literal"><span class="pre">*prefix*</span></tt> and <tt class="docutils literal"><span class="pre">*exec-prefix*</span></tt>
are <tt class="docutils literal"><span class="pre">/usr/local</span></tt>.</li>
<li>The default installation directory on Windows was <tt class="docutils literal"><span class="pre">C:\Program</span>
<span class="pre">Files\Python</span></tt> under Python 1.6a1, 1.5.2, and earlier.</li>
</ol>
<p><tt class="docutils literal"><span class="pre">*prefix*</span></tt> and <tt class="docutils literal"><span class="pre">*exec-prefix*</span></tt> stand for the directories that
Python is installed to, and where it finds its libraries at run-time.
They are always the same under Windows, and very often the same under
Unix and Mac OS X.  You can find out what your Python installation
uses for <tt class="docutils literal"><span class="pre">*prefix*</span></tt> and <tt class="docutils literal"><span class="pre">*exec-prefix*</span></tt> by running Python in
interactive mode and typing a few simple commands. Under Unix, just
type <tt class="docutils literal"><span class="pre">python</span></tt> at the shell prompt.  Under Windows, choose <em>Start ‣
Programs ‣ Python X.Y ‣ Python (command line)</em>.   Once the interpreter
is started, you type Python code at the prompt.  For example, on my
Linux system, I type the three Python statements shown below, and get
the output as shown, to find out my <tt class="docutils literal"><span class="pre">*prefix*</span></tt> and
<tt class="docutils literal"><span class="pre">*exec-prefix*</span></tt>:</p>
<blockquote>
Python 2.4 (#26, Aug  7 2004, 17:19:02)
Type &#8220;help&#8221;, &#8220;copyright&#8221;, &#8220;credits&#8221; or &#8220;license&#8221; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.prefix
&#8216;/usr&#8217;
&gt;&gt;&gt; sys.exec_prefix
&#8216;/usr&#8217;</blockquote>
<p>If you don&#8217;t want to install modules to the standard location, or if
you don&#8217;t have permission to write there, then you need to read about
alternate installations in section <em>Alternate Installation</em>.  If you
want to customize your installation directories more heavily, see
section <em>Custom Installation</em> on custom installations.</p>
</div>
</div>
<div class="section" id="alternate-installation">
<h3>Alternate Installation<a class="headerlink" href="#alternate-installation" title="Permalink to this headline">¶</a></h3>
<p>Often, it is necessary or desirable to install modules to a location
other than the standard location for third-party Python modules.  For
example, on a Unix system you might not have permission to write to
the standard third-party module directory.  Or you might wish to try
out a module before making it a standard part of your local Python
installation.  This is especially true when upgrading a distribution
already present: you want to make sure your existing base of scripts
still works with the new version before actually upgrading.</p>
<p>The Distutils <strong>install</strong> command is designed to make installing
module distributions to an alternate location simple and painless.
The basic idea is that you supply a base directory for the
installation, and the <strong>install</strong> command picks a set of directories
(called an <em>installation scheme</em>) under this base directory in which
to install files.  The details differ across platforms, so read
whichever of the following sections applies to you.</p>
<div class="section" id="alternate-installation-the-home-scheme">
<h4>Alternate installation: the home scheme<a class="headerlink" href="#alternate-installation-the-home-scheme" title="Permalink to this headline">¶</a></h4>
<p>The idea behind the &#8220;home scheme&#8221; is that you build and maintain a
personal stash of Python modules.  This scheme&#8217;s name is derived from
the idea of a &#8220;home&#8221; directory on Unix, since it&#8217;s not unusual for a
Unix user to make their home directory have a layout similar to
<tt class="docutils literal"><span class="pre">/usr/</span></tt> or <tt class="docutils literal"><span class="pre">/usr/local/</span></tt>. This scheme can be used by anyone,
regardless of the operating system their installing for.</p>
<p>Installing a new module distribution is as simple as</p>
<blockquote>
python setup.py install &#8211;home=&lt;dir&gt;</blockquote>
<p>where you can supply any directory you like for the <em>&#8211;home</em> option.
On Unix, lazy typists can just type a tilde (<tt class="docutils literal"><span class="pre">~</span></tt>); the <strong>install</strong>
command will expand this to your home directory:</p>
<blockquote>
python setup.py install &#8211;home=~</blockquote>
<p>The <em>&#8211;home</em> option defines the installation base directory.  Files
are installed to the following directories under the installation base
as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="32%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*home*/lib/python</span></tt></td>
<td><em>&#8211;install-purelib</em></td>
</tr>
<tr><td>non-pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*home*/lib/python</span></tt></td>
<td><em>&#8211;install-platlib</em></td>
</tr>
<tr><td>scripts</td>
<td><tt class="docutils literal"><span class="pre">*home*/bin</span></tt></td>
<td><em>&#8211;install-scripts</em></td>
</tr>
<tr><td>data</td>
<td><tt class="docutils literal"><span class="pre">*home*/share</span></tt></td>
<td><em>&#8211;install-data</em></td>
</tr>
</tbody>
</table>
<p>Changed in version 2.4: The <em>&#8211;home</em> option used to be supported only
on Unix.</p>
</div>
<div class="section" id="alternate-installation-unix-the-prefix-scheme">
<h4>Alternate installation: Unix (the prefix scheme)<a class="headerlink" href="#alternate-installation-unix-the-prefix-scheme" title="Permalink to this headline">¶</a></h4>
<p>The &#8220;prefix scheme&#8221; is useful when you wish to use one Python
installation to perform the build/install (i.e., to run the setup
script), but install modules into the third-party module directory of
a different Python installation (or something that looks like a
different Python installation).  If this sounds a trifle unusual, it
is&#8212;that&#8217;s why the &#8220;home scheme&#8221; comes first.  However, there are at
least two known cases where the prefix scheme will be useful.</p>
<p>First, consider that many Linux distributions put Python in <tt class="docutils literal"><span class="pre">/usr</span></tt>,
rather than the more traditional <tt class="docutils literal"><span class="pre">/usr/local</span></tt>.  This is entirely
appropriate, since in those cases Python is part of &#8220;the system&#8221;
rather than a local add-on. However, if you are installing Python
modules from source, you probably want them to go in
<tt class="docutils literal"><span class="pre">/usr/local/lib/python2.*X*</span></tt> rather than <tt class="docutils literal"><span class="pre">/usr/lib/python2.*X*</span></tt>.
This can be done with</p>
<blockquote>
/usr/bin/python setup.py install &#8211;prefix=/usr/local</blockquote>
<p>Another possibility is a network filesystem where the name used to
write to a remote directory is different from the name used to read
it: for example, the Python interpreter accessed as
<tt class="docutils literal"><span class="pre">/usr/local/bin/python</span></tt> might search for modules in
<tt class="docutils literal"><span class="pre">/usr/local/lib/python2.*X*</span></tt>, but those modules would have to be
installed to, say, <tt class="docutils literal"><span class="pre">/mnt/*&#64;server*/export/lib/python2.*X*</span></tt>.  This
could be done with</p>
<blockquote>
/usr/local/bin/python setup.py install <a class="reference external" href="mailto:--prefix=/mnt/&#37;&#52;&#48;server/export">--prefix=/mnt/<span>&#64;</span>server/export</a></blockquote>
<p>In either case, the <em>&#8211;prefix</em> option defines the installation base,
and the <em>&#8211;exec-prefix</em> option defines the platform-specific
installation base, which is used for platform-specific files.
(Currently, this just means non-pure module distributions, but could
be expanded to C libraries, binary executables, etc.)  If <em>&#8211;exec-
prefix</em> is not supplied, it defaults to <em>&#8211;prefix</em>.  Files are
installed as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="47%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*prefix*/lib/python*X.Y*/site-packages</span></tt></td>
<td><em>&#8211;install-purelib</em></td>
</tr>
<tr><td>non-pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*exec-prefix*/lib/python*X.Y*/site-packages</span></tt></td>
<td><em>&#8211;install-platlib</em></td>
</tr>
<tr><td>scripts</td>
<td><tt class="docutils literal"><span class="pre">*prefix*/bin</span></tt></td>
<td><em>&#8211;install-scripts</em></td>
</tr>
<tr><td>data</td>
<td><tt class="docutils literal"><span class="pre">*prefix*/share</span></tt></td>
<td><em>&#8211;install-data</em></td>
</tr>
</tbody>
</table>
<p>There is no requirement that <em>&#8211;prefix</em> or <em>&#8211;exec-prefix</em> actually
point to an alternate Python installation; if the directories listed
above do not already exist, they are created at installation time.</p>
<p>Incidentally, the real reason the prefix scheme is important is simply
that a standard Unix installation uses the prefix scheme, but with
<em>&#8211;prefix</em> and <em>&#8211;exec-prefix</em> supplied by Python itself as
<tt class="docutils literal"><span class="pre">sys.prefix</span></tt> and <tt class="docutils literal"><span class="pre">sys.exec_prefix</span></tt>.  Thus, you might think you&#8217;ll
never use the prefix scheme, but every time you run <tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span>
<span class="pre">install</span></tt> without any other options, you&#8217;re using it.</p>
<p>Note that installing extensions to an alternate Python installation
has no effect on how those extensions are built: in particular, the
Python header files (<tt class="docutils literal"><span class="pre">Python.h</span></tt> and friends) installed with the
Python interpreter used to run the setup script will be used in
compiling extensions.  It is your responsibility to ensure that the
interpreter used to run extensions installed in this way is compatible
with the interpreter used to build them.  The best way to do this is
to ensure that the two interpreters are the same version of Python
(possibly different builds, or possibly copies of the same build).
(Of course, if your <em>&#8211;prefix</em> and <em>&#8211;exec-prefix</em> don&#8217;t even point to
an alternate Python installation, this is immaterial.)</p>
</div>
<div class="section" id="alternate-installation-windows-the-prefix-scheme">
<h4>Alternate installation: Windows (the prefix scheme)<a class="headerlink" href="#alternate-installation-windows-the-prefix-scheme" title="Permalink to this headline">¶</a></h4>
<p>Windows has no concept of a user&#8217;s home directory, and since the
standard Python installation under Windows is simpler than under Unix,
the <em>&#8211;prefix</em> option has traditionally been used to install
additional packages in separate locations on Windows.</p>
<blockquote>
python setup.py install &#8211;prefix=&#8221;TempPython&#8221;</blockquote>
<p>to install modules to the <tt class="docutils literal"><span class="pre">\Temp\Python</span></tt> directory on the current
drive.</p>
<p>The installation base is defined by the <em>&#8211;prefix</em> option; the
<em>&#8211;exec-prefix</em> option is not supported under Windows. Files are
installed as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="32%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Installation Directory</th>
<th class="head">Override option</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*prefix*</span></tt></td>
<td><em>&#8211;install-purelib</em></td>
</tr>
<tr><td>non-pure module distribution</td>
<td><tt class="docutils literal"><span class="pre">*prefix*</span></tt></td>
<td><em>&#8211;install-platlib</em></td>
</tr>
<tr><td>scripts</td>
<td><tt class="docutils literal"><span class="pre">*prefix*\Scripts</span></tt></td>
<td><em>&#8211;install-scripts</em></td>
</tr>
<tr><td>data</td>
<td><tt class="docutils literal"><span class="pre">*prefix*\Data</span></tt></td>
<td><em>&#8211;install-data</em></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="custom-installation">
<h3>Custom Installation<a class="headerlink" href="#custom-installation" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, the alternate installation schemes described in section
<em>Alternate Installation</em> just don&#8217;t do what you want.  You might want
to tweak just one or two directories while keeping everything under
the same base directory, or you might want to completely redefine the
installation scheme.  In either case, you&#8217;re creating a <em>custom
installation scheme</em>.</p>
<p>You probably noticed the column of &#8220;override options&#8221; in the tables
describing the alternate installation schemes above.  Those options
are how you define a custom installation scheme.  These override
options can be relative, absolute, or explicitly defined in terms of
one of the installation base directories. (There are two installation
base directories, and they are normally the same&#8212; they only differ
when you use the Unix &#8220;prefix scheme&#8221; and supply different <em>&#8211;prefix</em>
and <em>&#8211;exec-prefix</em> options.)</p>
<p>For example, say you&#8217;re installing a module distribution to your home
directory under Unix&#8212;but you want scripts to go in <tt class="docutils literal"><span class="pre">~/scripts</span></tt>
rather than <tt class="docutils literal"><span class="pre">~/bin</span></tt>. As you might expect, you can override this
directory with the <em>&#8211;install-scripts</em> option; in this case, it makes
most sense to supply a relative path, which will be interpreted
relative to the installation base directory (your home directory, in
this case):</p>
<blockquote>
python setup.py install &#8211;home=~ &#8211;install-scripts=scripts</blockquote>
<p>Another Unix example: suppose your Python installation was built and
installed with a prefix of <tt class="docutils literal"><span class="pre">/usr/local/python</span></tt>, so under a standard
installation scripts will wind up in <tt class="docutils literal"><span class="pre">/usr/local/python/bin</span></tt>.  If
you want them in <tt class="docutils literal"><span class="pre">/usr/local/bin</span></tt> instead, you would supply this
absolute directory for the <em>&#8211;install-scripts</em> option:</p>
<blockquote>
python setup.py install &#8211;install-scripts=/usr/local/bin</blockquote>
<p>(This performs an installation using the &#8220;prefix scheme,&#8221; where the
prefix is whatever your Python interpreter was installed with&#8212;
<tt class="docutils literal"><span class="pre">/usr/local/python</span></tt> in this case.)</p>
<p>If you maintain Python on Windows, you might want third-party modules
to live in a subdirectory of <tt class="docutils literal"><span class="pre">*prefix*</span></tt>, rather than right in
<tt class="docutils literal"><span class="pre">*prefix*</span></tt> itself.  This is almost as easy as customizing the script
installation directory &#8212;you just have to remember that there are two
types of modules to worry about, pure modules and non-pure modules
(i.e., modules from a non-pure distribution). For example:</p>
<blockquote>
python setup.py install &#8211;install-purelib=Site &#8211;install-platlib=Site</blockquote>
<p>The specified installation directories are relative to <tt class="docutils literal"><span class="pre">*prefix*</span></tt>.
Of course, you also have to ensure that these directories are in
Python&#8217;s module search path, such as by putting a <tt class="docutils literal"><span class="pre">.pth</span></tt> file in
<tt class="docutils literal"><span class="pre">*prefix*</span></tt>.  See section <em>Modifying Python&#8217;s Search Path</em> to find
out how to modify Python&#8217;s search path.</p>
<p>If you want to define an entire installation scheme, you just have to
supply all of the installation directory options.  The recommended way
to do this is to supply relative paths; for example, if you want to
maintain all Python module-related files under <tt class="docutils literal"><span class="pre">python</span></tt> in your home
directory, and you want a separate directory for each platform that
you use your home directory from, you might define the following
installation scheme:</p>
<blockquote>
<dl class="docutils">
<dt>python setup.py install &#8211;home=~ </dt>
<dd>&#8211;install-purelib=python/lib &#8211;install-platlib=python/lib.$PLAT &#8211;install-scripts=python/scripts
&#8211;install-data=python/data</dd>
</dl>
</blockquote>
<p>or, equivalently,</p>
<blockquote>
<dl class="docutils">
<dt>python setup.py install &#8211;home=~/python </dt>
<dd>&#8211;install-purelib=lib &#8211;install-platlib=&#8217;lib.$PLAT&#8217; &#8211;install-scripts=scripts
&#8211;install-data=data</dd>
</dl>
</blockquote>
<p><tt class="docutils literal"><span class="pre">$PLAT</span></tt> is not (necessarily) an environment variable&#8212;it will be
expanded by the Distutils as it parses your command line options, just
as it does when parsing your configuration file(s).</p>
<p>Obviously, specifying the entire installation scheme every time you
install a new module distribution would be very tedious.  Thus, you
can put these options into your Distutils config file (see section
<em>Distutils Configuration Files</em>):</p>
<blockquote>
[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data</blockquote>
<p>or, equivalently,</p>
<blockquote>
[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data</blockquote>
<p>Note that these two are <em>not</em> equivalent if you supply a different
installation base directory when you run the setup script.  For
example,</p>
<blockquote>
python setup.py install &#8211;install-base=/tmp</blockquote>
<p>would install pure modules to <tt class="docutils literal"><span class="pre">*/tmp/python/lib*</span></tt> in the first case,
and to <tt class="docutils literal"><span class="pre">*/tmp/lib*</span></tt> in the second case.  (For the second case, you
probably want to supply an installation base of <tt class="docutils literal"><span class="pre">/tmp/python</span></tt>.)</p>
<p>You probably noticed the use of <tt class="docutils literal"><span class="pre">$HOME</span></tt> and <tt class="docutils literal"><span class="pre">$PLAT</span></tt> in the sample
configuration file input.  These are Distutils configuration
variables, which bear a strong resemblance to environment variables.
In fact, you can use environment variables in config files on
platforms that have such a notion but the Distutils additionally
define a few extra variables that may not be in your environment, such
as <tt class="docutils literal"><span class="pre">$PLAT</span></tt>.  (And of course, on systems that don&#8217;t have environment
variables, such as Mac OS 9, the configuration variables supplied by
the Distutils are the only ones you can use.) See section <em>Distutils
Configuration Files</em> for details.</p>
<div class="section" id="modifying-python-s-search-path">
<h4>Modifying Python&#8217;s Search Path<a class="headerlink" href="#modifying-python-s-search-path" title="Permalink to this headline">¶</a></h4>
<p>When the Python interpreter executes an <tt class="docutils literal"><span class="pre">import</span></tt> statement, it
searches for both Python code and extension modules along a search
path.  A default value for the path is configured into the Python
binary when the interpreter is built. You can determine the path by
importing the <tt class="docutils literal"><span class="pre">sys</span></tt> module and printing the value of <tt class="docutils literal"><span class="pre">sys.path</span></tt>.</p>
<blockquote>
<p>$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type &#8220;help&#8221;, &#8220;copyright&#8221;, &#8220;credits&#8221; or &#8220;license&#8221; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#8216;&#8217;, &#8216;/usr/local/lib/python2.3&#8217;, &#8216;/usr/local/lib/python2.3/plat-linux2&#8217;,</p>
<blockquote>
&#8216;/usr/local/lib/python2.3/lib-tk&#8217;, &#8216;/usr/local/lib/python2.3/lib-dynload&#8217;,
&#8216;/usr/local/lib/python2.3/site-packages&#8217;]</blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</blockquote>
<p>The null string in <tt class="docutils literal"><span class="pre">sys.path</span></tt> represents the current working
directory.</p>
<p>The expected convention for locally installed packages is to put them
in the <tt class="docutils literal"><span class="pre">*...*/site-packages/</span></tt> directory, but you may want to install
Python modules into some arbitrary directory.  For example, your site
may have a convention of keeping all software related to the web
server under <tt class="docutils literal"><span class="pre">/www</span></tt>. Add-on Python modules might then belong in
<tt class="docutils literal"><span class="pre">/www/python</span></tt>, and in order to import them, this directory must be
added to <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  There are several different ways to add the
directory.</p>
<p>The most convenient way is to add a path configuration file to a
directory that&#8217;s already on Python&#8217;s path, usually to the
<tt class="docutils literal"><span class="pre">.../site-packages/</span></tt> directory.  Path configuration files have an
extension of <tt class="docutils literal"><span class="pre">.pth</span></tt>, and each line must contain a single path that
will be appended to <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  (Because the new paths are appended
to <tt class="docutils literal"><span class="pre">sys.path</span></tt>, modules in the added directories will not override
standard modules.  This means you can&#8217;t use this mechanism for
installing fixed versions of standard modules.)</p>
<p>Paths can be absolute or relative, in which case they&#8217;re relative to
the directory containing the <tt class="docutils literal"><span class="pre">.pth</span></tt> file.  See the documentation of
the <tt class="docutils literal"><span class="pre">site</span></tt> module for more information.</p>
<p>A slightly less convenient way is to edit the <tt class="docutils literal"><span class="pre">site.py</span></tt> file in
Python&#8217;s standard library, and modify <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  <tt class="docutils literal"><span class="pre">site.py</span></tt> is
automatically imported when the Python interpreter is executed, unless
the <em>-S</em> switch is supplied to suppress this behaviour.  So you could
simply edit <tt class="docutils literal"><span class="pre">site.py</span></tt> and add two lines to it:</p>
<blockquote>
import sys
sys.path.append(&#8216;/www/python/&#8217;)</blockquote>
<p>However, if you reinstall the same major version of Python (perhaps
when upgrading from 2.2 to 2.2.2, for example) <tt class="docutils literal"><span class="pre">site.py</span></tt> will be
overwritten by the stock version.  You&#8217;d have to remember that it was
modified and save a copy before doing the installation.</p>
<p>There are two environment variables that can modify <tt class="docutils literal"><span class="pre">sys.path</span></tt>.
<strong>PYTHONHOME</strong> sets an alternate value for the prefix of the Python
installation.  For example, if <strong>PYTHONHOME</strong> is set to
<tt class="docutils literal"><span class="pre">/www/python</span></tt>, the search path will be set to <tt class="docutils literal"><span class="pre">['',</span>
<span class="pre">'/www/python/lib/pythonX.Y/',</span> <span class="pre">'/www/python/lib/pythonX.Y/plat-linux2',</span>
<span class="pre">...]</span></tt>.</p>
<p>The <strong>PYTHONPATH</strong> variable can be set to a list of paths that will be
added to the beginning of <tt class="docutils literal"><span class="pre">sys.path</span></tt>.  For example, if
<strong>PYTHONPATH</strong> is set to <tt class="docutils literal"><span class="pre">/www/python:/opt/py</span></tt>, the search path will
begin with <tt class="docutils literal"><span class="pre">['/www/python',</span> <span class="pre">'/opt/py']</span></tt>.  (Note that directories
must exist in order to be added to <tt class="docutils literal"><span class="pre">sys.path</span></tt>; the <tt class="docutils literal"><span class="pre">site</span></tt> module
removes paths that don&#8217;t exist.)</p>
<p>Finally, <tt class="docutils literal"><span class="pre">sys.path</span></tt> is just a regular Python list, so any Python
application can modify it by adding or removing entries.</p>
</div>
</div>
<div class="section" id="distutils-configuration-files">
<h3>Distutils Configuration Files<a class="headerlink" href="#distutils-configuration-files" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, you can use Distutils configuration files to
record personal or site preferences for any Distutils options.  That
is, any option to any command can be stored in one of two or three
(depending on your platform) configuration files, which will be
consulted before the command-line is parsed. This means that
configuration files will override default values, and the command-line
will in turn override configuration files.  Furthermore, if multiple
configuration files apply, values from &#8220;earlier&#8221; files are overridden
by &#8220;later&#8221; files.</p>
<div class="section" id="location-and-names-of-config-files">
<h4>Location and names of config files<a class="headerlink" href="#location-and-names-of-config-files" title="Permalink to this headline">¶</a></h4>
<p>The names and locations of the configuration files vary slightly
across platforms.  On Unix and Mac OS X, the three configuration files
(in the order they are processed) are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="71%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Location and filename</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>system</td>
<td><tt class="docutils literal"><span class="pre">*prefix*/lib/python*ver*/distutils/distutils.cfg</span></tt></td>
<td><ol class="first last arabic simple">
<li></li>
</ol>
</td>
</tr>
<tr><td>personal</td>
<td><tt class="docutils literal"><span class="pre">$HOME/.pydistutils.cfg</span></tt></td>
<td><ol class="first last arabic simple" start="2">
<li></li>
</ol>
</td>
</tr>
<tr><td>local</td>
<td><tt class="docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td><ol class="first last arabic simple" start="3">
<li></li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>And on Windows, the configuration files are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="67%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type of file</th>
<th class="head">Location and filename</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>system</td>
<td><tt class="docutils literal"><span class="pre">*prefix*\Lib\distutils\distutils.cfg</span></tt></td>
<td><ol class="first last arabic simple" start="4">
<li></li>
</ol>
</td>
</tr>
<tr><td>personal</td>
<td><tt class="docutils literal"><span class="pre">%HOME%\pydistutils.cfg</span></tt></td>
<td><ol class="first last arabic simple" start="5">
<li></li>
</ol>
</td>
</tr>
<tr><td>local</td>
<td><tt class="docutils literal"><span class="pre">setup.cfg</span></tt></td>
<td><ol class="first last arabic simple" start="3">
<li></li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol class="arabic simple">
<li>Strictly speaking, the system-wide configuration file lives in the
directory where the Distutils are installed; under Python 1.6 and
later on Unix, this is as shown. For Python 1.5.2, the Distutils
will normally be installed to
<tt class="docutils literal"><span class="pre">*prefix*/lib/python1.5/site-packages/distutils</span></tt>, so the system
configuration file should be put there under Python 1.5.2.</li>
<li>On Unix, if the <strong>HOME</strong> environment variable is not defined, the
user&#8217;s home directory will be determined with the <tt class="docutils literal"><span class="pre">getpwuid()</span></tt>
function from the standard <tt class="docutils literal"><span class="pre">pwd</span></tt> module.</li>
<li>I.e., in the current directory (usually the location of the setup
script).</li>
<li>(See also note (1).)  Under Python 1.6 and later, Python&#8217;s default
&#8220;installation prefix&#8221; is <tt class="docutils literal"><span class="pre">C:\Python</span></tt>, so the system configuration
file is normally <tt class="docutils literal"><span class="pre">C:\Python\Lib\distutils\distutils.cfg</span></tt>. Under
Python 1.5.2, the default prefix was <tt class="docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></tt>,
and the Distutils were not part of the standard library&#8212;so the
system configuration file would be <tt class="docutils literal"><span class="pre">C:\Program</span>
<span class="pre">Files\Python\distutils\distutils.cfg</span></tt> in a standard Python 1.5.2
installation under Windows.</li>
<li>On Windows, if the <strong>HOME</strong> environment variable is not defined, no
personal configuration file will be found or used.  (In other
words, the Distutils make no attempt to guess your home directory
on Windows.)</li>
</ol>
</div>
<div class="section" id="syntax-of-config-files">
<h4>Syntax of config files<a class="headerlink" href="#syntax-of-config-files" title="Permalink to this headline">¶</a></h4>
<p>The Distutils configuration files all have the same syntax.  The
config files are grouped into sections.  There is one section for each
Distutils command, plus a <tt class="docutils literal"><span class="pre">global</span></tt> section for global options that
affect every command.  Each section consists of one option per line,
specified as <tt class="docutils literal"><span class="pre">option=value</span></tt>.</p>
<p>For example, the following is a complete config file that just forces
all commands to run quietly by default:</p>
<blockquote>
[global]
verbose=0</blockquote>
<p>If this is installed as the system config file, it will affect all
processing of any Python module distribution by any user on the
current system.  If it is installed as your personal config file (on
systems that support them), it will affect only module distributions
processed by you.  And if it is used as the <tt class="docutils literal"><span class="pre">setup.cfg</span></tt> for a
particular module distribution, it affects only that distribution.</p>
<p>You could override the default &#8220;build base&#8221; directory and make the
<strong>build*</strong> commands always forcibly rebuild all files with the
following:</p>
<blockquote>
[build]
build-base=blib
force=1</blockquote>
<p>which corresponds to the command-line arguments</p>
<blockquote>
python setup.py build &#8211;build-base=blib &#8211;force</blockquote>
<p>except that including the <strong>build</strong> command on the command-line means
that command will be run.  Including a particular command in config
files has no such implication; it only means that if the command is
run, the options in the config file will apply.  (Or if other commands
that derive values from it are run, they will use the values in the
config file.)</p>
<p>You can find out the complete list of options for any command using
the <em>&#8211;help</em> option, e.g.:</p>
<blockquote>
python setup.py build &#8211;help</blockquote>
<p>and you can find out the complete list of global options by using
<em>&#8211;help</em> without a command:</p>
<blockquote>
python setup.py &#8211;help</blockquote>
<p>See also the &#8220;Reference&#8221; section of the &#8220;Distributing Python Modules&#8221;
manual.</p>
</div>
</div>
<div class="section" id="building-extensions-tips-and-tricks">
<h3>Building Extensions: Tips and Tricks<a class="headerlink" href="#building-extensions-tips-and-tricks" title="Permalink to this headline">¶</a></h3>
<p>Whenever possible, the Distutils try to use the configuration
information made available by the Python interpreter used to run the
<tt class="docutils literal"><span class="pre">setup.py</span></tt> script. For example, the same compiler and linker flags
used to compile Python will also be used for compiling extensions.
Usually this will work well, but in complicated situations this might
be inappropriate.  This section discusses how to override the usual
Distutils behaviour.</p>
<div class="section" id="tweaking-compiler-linker-flags">
<h4>Tweaking compiler/linker flags<a class="headerlink" href="#tweaking-compiler-linker-flags" title="Permalink to this headline">¶</a></h4>
<p>Compiling a Python extension written in C or C++ will sometimes
require specifying custom flags for the compiler and linker in order
to use a particular library or produce a special kind of object code.
This is especially true if the extension hasn&#8217;t been tested on your
platform, or if you&#8217;re trying to cross-compile Python.</p>
<p>In the most general case, the extension author might have foreseen
that compiling the extensions would be complicated, and provided a
<tt class="docutils literal"><span class="pre">Setup</span></tt> file for you to edit.  This will likely only be done if the
module distribution contains many separate extension modules, or if
they often require elaborate sets of compiler flags in order to work.</p>
<p>A <tt class="docutils literal"><span class="pre">Setup</span></tt> file, if present, is parsed in order to get a list of
extensions to build.  Each line in a <tt class="docutils literal"><span class="pre">Setup</span></tt> describes a single
module.  Lines have the following structure:</p>
<blockquote>
module ... [sourcefile ...] [cpparg ...] [library ...]</blockquote>
<p>Let&#8217;s examine each of the fields in turn.</p>
<ul class="simple">
<li><em>module</em> is the name of the extension module to be built, and should
be a valid Python identifier.  You can&#8217;t just change this in order
to rename a module (edits to the source code would also be needed),
so this should be left alone.</li>
<li><em>sourcefile</em> is anything that&#8217;s likely to be a source code file, at
least judging by the filename.  Filenames ending in <tt class="docutils literal"><span class="pre">.c</span></tt> are
assumed to be written in C, filenames ending in <tt class="docutils literal"><span class="pre">.C</span></tt>, <tt class="docutils literal"><span class="pre">.cc</span></tt>, and
<tt class="docutils literal"><span class="pre">.c++</span></tt> are assumed to be C++, and filenames ending in <tt class="docutils literal"><span class="pre">.m</span></tt> or
<tt class="docutils literal"><span class="pre">.mm</span></tt> are assumed to be in Objective C.</li>
<li><em>cpparg</em> is an argument for the C preprocessor,  and is anything
starting with <em>-I</em>, <em>-D</em>, <em>-U</em> or <em>-C</em>.</li>
<li><em>library</em> is anything ending in <tt class="docutils literal"><span class="pre">.a</span></tt> or beginning with <em>-l</em> or
<em>-L</em>.</li>
</ul>
<p>If a particular platform requires a special library on your platform,
you can add it by editing the <tt class="docutils literal"><span class="pre">Setup</span></tt> file and running <tt class="docutils literal"><span class="pre">python</span>
<span class="pre">setup.py</span> <span class="pre">build</span></tt>. For example, if the module defined by the line</p>
<blockquote>
foo foomodule.c</blockquote>
<p>must be linked with the math library <tt class="docutils literal"><span class="pre">libm.a</span></tt> on your platform,
simply add <em>-lm</em> to the line:</p>
<blockquote>
foo foomodule.c -lm</blockquote>
<p>Arbitrary switches intended for the compiler or the linker can be
supplied with the <em>-Xcompiler</em> <em>arg</em> and <em>-Xlinker</em> <em>arg</em> options:</p>
<blockquote>
foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm</blockquote>
<p>The next option after <em>-Xcompiler</em> and <em>-Xlinker</em> will be appended to
the proper command line, so in the above example the compiler will be
passed the <em>-o32</em> option, and the linker will be passed <em>-shared</em>.  If
a compiler option requires an argument, you&#8217;ll have to supply multiple
<em>-Xcompiler</em> options; for example, to pass <tt class="docutils literal"><span class="pre">-x</span> <span class="pre">c++</span></tt> the <tt class="docutils literal"><span class="pre">Setup</span></tt>
file would have to contain <tt class="docutils literal"><span class="pre">-Xcompiler</span> <span class="pre">-x</span> <span class="pre">-Xcompiler</span> <span class="pre">c++</span></tt>.</p>
<p>Compiler flags can also be supplied through setting the <strong>CFLAGS</strong>
environment variable.  If set, the contents of <strong>CFLAGS</strong> will be
added to the compiler flags specified in the  <tt class="docutils literal"><span class="pre">Setup</span></tt> file.</p>
</div>
<div class="section" id="using-non-microsoft-compilers-on-windows">
<h4>Using non-Microsoft compilers on Windows<a class="headerlink" href="#using-non-microsoft-compilers-on-windows" title="Permalink to this headline">¶</a></h4>
<div class="section" id="borland-codegear-c">
<h5>Borland/CodeGear C++<a class="headerlink" href="#borland-codegear-c" title="Permalink to this headline">¶</a></h5>
<p>This subsection describes the necessary steps to use Distutils with
the Borland C++ compiler version 5.5.  First you have to know that
Borland&#8217;s object file format (OMF) is different from the format used
by the Python version you can download from the Python or ActiveState
Web site.  (Python is built with Microsoft Visual C++, which uses COFF
as the object file format.) For this reason you have to convert
Python&#8217;s library <tt class="docutils literal"><span class="pre">python25.lib</span></tt> into the Borland format.  You can do
this as follows:</p>
<blockquote>
coff2omf python25.lib python25_bcpp.lib</blockquote>
<p>The <tt class="docutils literal"><span class="pre">coff2omf</span></tt> program comes with the Borland compiler.  The file
<tt class="docutils literal"><span class="pre">python25.lib</span></tt> is in the <tt class="docutils literal"><span class="pre">Libs</span></tt> directory of your Python
installation.  If your extension uses other libraries (zlib, ...) you
have to convert them too.</p>
<p>The converted files have to reside in the same directories as the
normal libraries.</p>
<p>How does Distutils manage to use these libraries with their changed
names?  If the extension needs a library (eg. <tt class="docutils literal"><span class="pre">foo</span></tt>) Distutils
checks first if it finds a library with suffix <tt class="docutils literal"><span class="pre">_bcpp</span></tt> (eg.
<tt class="docutils literal"><span class="pre">foo_bcpp.lib</span></tt>) and then uses this library.  In the case it doesn&#8217;t
find such a special library it uses the default name (<tt class="docutils literal"><span class="pre">foo.lib</span></tt>.)
[1]</p>
<p>To let Distutils compile your extension with Borland C++ you now have
to type:</p>
<blockquote>
python setup.py build &#8211;compiler=bcpp</blockquote>
<p>If you want to use the Borland C++ compiler as the default, you could
specify this in your personal or system-wide configuration file for
Distutils (see section <em>Distutils Configuration Files</em>.)</p>
<p>See also:</p>
<blockquote>
<dl class="docutils">
<dt>C++Builder Compiler</dt>
<dd>Information about the free C++ compiler from Borland, including
links to the download pages.</dd>
<dt>Creating Python Extensions Using Borland&#8217;s Free Compiler</dt>
<dd>Document describing how to use Borland&#8217;s free command-line C++
compiler to build Python.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="gnu-c-cygwin-mingw">
<h5>GNU C / Cygwin / MinGW<a class="headerlink" href="#gnu-c-cygwin-mingw" title="Permalink to this headline">¶</a></h5>
<p>These instructions only apply if you&#8217;re using a version of Python
prior  to 2.4.1 with a MinGW prior to 3.0.0 (with
binutils-2.13.90-20030111-1).</p>
<p>This section describes the necessary steps to use Distutils with the
GNU C/C++ compilers in their Cygwin and MinGW distributions. [2] For a
Python interpreter that was built with Cygwin, everything should work
without any of these following steps.</p>
<p>These compilers require some special libraries. This task is more
complex than for Borland&#8217;s C++, because there is no program to convert
the library.  First you have to create a list of symbols which the
Python DLL exports. (You can find a good program for this task at http
://www.emmestech.com/software/cygwin/pexports-0.43/download_pexports.h
tml)</p>
<blockquote>
pexports python25.dll &gt;python25.def</blockquote>
<p>The location of an installed <tt class="docutils literal"><span class="pre">python25.dll</span></tt> will depend on the
installation options and the version and language of Windows.  In a
&#8220;just for me&#8221; installation, it will appear in the root of the
installation directory.  In a shared installation, it will be located
in the system directory.</p>
<p>Then you can create from these information an import library for gcc.</p>
<blockquote>
/cygwin/bin/dlltool &#8211;dllname python25.dll &#8211;def python25.def &#8211;output-lib libpython25.a</blockquote>
<p>The resulting library has to be placed in the same directory as
<tt class="docutils literal"><span class="pre">python25.lib</span></tt>. (Should be the <tt class="docutils literal"><span class="pre">libs</span></tt> directory under your Python
installation directory.)</p>
<p>If your extension uses other libraries (zlib,...) you might  have to
convert them too. The converted files have to reside in the same
directories as the normal libraries do.</p>
<p>To let Distutils compile your extension with Cygwin you now have to
type</p>
<blockquote>
python setup.py build &#8211;compiler=cygwin</blockquote>
<p>and for Cygwin in no-cygwin mode [3] or for MinGW type:</p>
<blockquote>
python setup.py build &#8211;compiler=mingw32</blockquote>
<p>If you want to use any of these options/compilers as default, you
should consider to write it in your personal or system-wide
configuration file for Distutils (see section <em>Distutils Configuration
Files</em>.)</p>
<p>See also:</p>
<blockquote>
<dl class="docutils">
<dt>Building Python modules on MS Windows platform with MinGW</dt>
<dd>Information about building the required libraries for the MinGW
environment.</dd>
</dl>
</blockquote>
<p>-[ Footnotes ]-</p>
<dl class="docutils">
<dt>[1] This also means you could replace all existing COFF-libraries with</dt>
<dd>OMF-libraries of the same name.</dd>
<dt>[2] Check <a class="reference external" href="http://sources.redhat.com/cygwin/">http://sources.redhat.com/cygwin/</a> and <a class="reference external" href="http://www.mingw.org/">http://www.mingw.org/</a></dt>
<dd>for more information</dd>
<dt>[3] Then you have no POSIX emulation available, but you also don&#8217;t</dt>
<dd>need <tt class="docutils literal"><span class="pre">cygwin1.dll</span></tt>.</dd>
</dl>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Jython v2.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2009, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
    </div>
  </body>
</html>