<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Data model &mdash; Jython v2.5.0 documentation</title>
    <link rel="stylesheet" href="../_static/green-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Jython v2.5.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li><a href="../index.html">Jython v2.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/jython.png" alt="Logo"/>
            </a></p>
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">3. Data model</a><ul>
<li><a class="reference external" href="#objects-values-and-types">3.1. Objects, values and types</a></li>
<li><a class="reference external" href="#the-standard-type-hierarchy">3.2. The standard type hierarchy</a></li>
<li><a class="reference external" href="#new-style-and-classic-classes">3.3. New-style and classic classes</a></li>
<li><a class="reference external" href="#special-method-names">3.4. Special method names</a><ul>
<li><a class="reference external" href="#basic-customization">3.4.1. Basic customization</a></li>
<li><a class="reference external" href="#customizing-attribute-access">3.4.2. Customizing attribute access</a><ul>
<li><a class="reference external" href="#more-attribute-access-for-new-style-classes">3.4.2.1. More attribute access for new-style classes</a></li>
<li><a class="reference external" href="#implementing-descriptors">3.4.2.2. Implementing Descriptors</a></li>
<li><a class="reference external" href="#invoking-descriptors">3.4.2.3. Invoking Descriptors</a></li>
<li><a class="reference external" href="#slots">3.4.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference external" href="#customizing-class-creation">3.4.3. Customizing class creation</a></li>
<li><a class="reference external" href="#emulating-callable-objects">3.4.4. Emulating callable objects</a></li>
<li><a class="reference external" href="#emulating-container-types">3.4.5. Emulating container types</a></li>
<li><a class="reference external" href="#additional-methods-for-emulation-of-sequence-types">3.4.6. Additional methods for emulation of sequence types</a></li>
<li><a class="reference external" href="#emulating-numeric-types">3.4.7. Emulating numeric types</a></li>
<li><a class="reference external" href="#coercion-rules">3.4.8. Coercion rules</a></li>
<li><a class="reference external" href="#with-statement-context-managers">3.4.9. With Statement Context Managers</a></li>
<li><a class="reference external" href="#special-method-lookup-for-old-style-classes">3.4.10. Special method lookup for old-style classes</a></li>
<li><a class="reference external" href="#special-method-lookup-for-new-style-classes">3.4.11. Special method lookup for new-style classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/reference/datamodel.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="data-model">
<h1>3. Data model<a class="headerlink" href="#data-model" title="Permalink to this headline">¶</a></h1>
<div class="section" id="objects-values-and-types">
<h2>3.1. Objects, values and types<a class="headerlink" href="#objects-values-and-types" title="Permalink to this headline">¶</a></h2>
<p><em>Objects</em> are Python&#8217;s abstraction for data.  All data in a Python
program is represented by objects or by relations between objects. (In
a sense, and in conformance to Von Neumann&#8217;s model of a &#8220;stored
program computer,&#8221; code is also represented by objects.)</p>
<p>Every object has an identity, a type and a value.  An object&#8217;s
<em>identity</em> never changes once it has been created; you may think of it
as the object&#8217;s address in memory.  The &#8216;<tt class="docutils literal"><span class="pre">is</span></tt>&#8216; operator compares the
identity of two objects; the <tt class="docutils literal"><span class="pre">id()</span></tt> function returns an integer
representing its identity (currently implemented as its address). An
object&#8217;s <em>type</em> is also unchangeable. [1] An object&#8217;s type determines
the operations that the object supports (e.g., &#8220;does it have a
length?&#8221;) and also defines the possible values for objects of that
type.  The <tt class="docutils literal"><span class="pre">type()</span></tt> function returns an object&#8217;s type (which is an
object itself).  The <em>value</em> of some objects can change.  Objects
whose value can change are said to be <em>mutable</em>; objects whose value
is unchangeable once they are created are called <em>immutable</em>. (The
value of an immutable container object that contains a reference to a
mutable object can change when the latter&#8217;s value is changed; however
the container is still considered immutable, because the collection of
objects it contains cannot be changed.  So, immutability is not
strictly the same as having an unchangeable value, it is more subtle.)
An object&#8217;s mutability is determined by its type; for instance,
numbers, strings and tuples are immutable, while dictionaries and
lists are mutable.</p>
<p>Objects are never explicitly destroyed; however, when they become
unreachable they may be garbage-collected.  An implementation is
allowed to postpone garbage collection or omit it altogether &#8212; it is
a matter of implementation quality how garbage collection is
implemented, as long as no objects are collected that are still
reachable.  (Implementation note: CPython currently uses a reference-
counting scheme with (optional) delayed detection of cyclically linked
garbage, which collects most objects as soon as they become
unreachable, but is not guaranteed to collect garbage containing
circular references.  See the documentation of the <tt class="docutils literal"><span class="pre">gc</span></tt> module for
information on controlling the collection of cyclic garbage.  Other
implementations act differently and CPython may change.)</p>
<p>Note that the use of the implementation&#8217;s tracing or debugging
facilities may keep objects alive that would normally be collectable.
Also note that catching an exception with a &#8216;<tt class="docutils literal"><span class="pre">try</span></tt>...``except``&#8217;
statement may keep objects alive.</p>
<p>Some objects contain references to &#8220;external&#8221; resources such as open
files or windows.  It is understood that these resources are freed
when the object is garbage-collected, but since garbage collection is
not guaranteed to happen, such objects also provide an explicit way to
release the external resource, usually a <tt class="docutils literal"><span class="pre">close()</span></tt> method. Programs
are strongly recommended to explicitly close such objects.  The
&#8216;<tt class="docutils literal"><span class="pre">try</span></tt>...``finally``&#8217; statement provides a convenient way to do
this.</p>
<p>Some objects contain references to other objects; these are called
<em>containers</em>. Examples of containers are tuples, lists and
dictionaries.  The references are part of a container&#8217;s value.  In
most cases, when we talk about the value of a container, we imply the
values, not the identities of the contained objects; however, when we
talk about the mutability of a container, only the identities of the
immediately contained objects are implied.  So, if an immutable
container (like a tuple) contains a reference to a mutable object, its
value changes if that mutable object is changed.</p>
<p>Types affect almost all aspects of object behavior.  Even the
importance of object identity is affected in some sense: for immutable
types, operations that compute new values may actually return a
reference to any existing object with the same type and value, while
for mutable objects this is not allowed.  E.g., after <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span>
<span class="pre">1</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> may or may not refer to the same object with the
value one, depending on the implementation, but after <tt class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span>
<span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">c</span></tt> and <tt class="docutils literal"><span class="pre">d</span></tt> are guaranteed to refer to two different,
unique, newly created empty lists. (Note that <tt class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></tt> assigns
the same object to both <tt class="docutils literal"><span class="pre">c</span></tt> and <tt class="docutils literal"><span class="pre">d</span></tt>.)</p>
</div>
<div class="section" id="the-standard-type-hierarchy">
<h2>3.2. The standard type hierarchy<a class="headerlink" href="#the-standard-type-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>Below is a list of the types that are built into Python.  Extension
modules (written in C, Java, or other languages, depending on the
implementation) can define additional types.  Future versions of
Python may add types to the type hierarchy (e.g., rational numbers,
efficiently stored arrays of integers, etc.).</p>
<p>Some of the type descriptions below contain a paragraph listing
&#8216;special attributes.&#8217;  These are attributes that provide access to the
implementation and are not intended for general use.  Their definition
may change in the future.</p>
<dl class="docutils">
<dt>None</dt>
<dd>This type has a single value.  There is a single object with this
value. This object is accessed through the built-in name <tt class="xref docutils literal"><span class="pre">None</span></tt>.
It is used to signify the absence of a value in many situations,
e.g., it is returned from functions that don&#8217;t explicitly return
anything. Its truth value is false.</dd>
<dt>NotImplemented</dt>
<dd>This type has a single value.  There is a single object with this
value. This object is accessed through the built-in name
<tt class="docutils literal"><span class="pre">NotImplemented</span></tt>. Numeric methods and rich comparison methods may
return this value if they do not implement the operation for the
operands provided.  (The interpreter will then try the reflected
operation, or some other fallback, depending on the operator.)  Its
truth value is true.</dd>
<dt>Ellipsis</dt>
<dd>This type has a single value.  There is a single object with this
value. This object is accessed through the built-in name
<tt class="docutils literal"><span class="pre">Ellipsis</span></tt>. It is used to indicate the presence of the <tt class="docutils literal"><span class="pre">...</span></tt>
syntax in a slice.  Its truth value is true.</dd>
<dt><tt class="docutils literal"><span class="pre">numbers.Number</span></tt></dt>
<dd><p class="first">These are created by numeric literals and returned as results by
arithmetic operators and arithmetic built-in functions.  Numeric
objects are immutable; once created their value never changes.
Python numbers are of course strongly related to mathematical
numbers, but subject to the limitations of numerical representation
in computers.</p>
<p>Python distinguishes between integers, floating point numbers, and
complex numbers:</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">numbers.Integral</span></tt></dt>
<dd><p class="first">These represent elements from the mathematical set of integers
(positive and negative).</p>
<p>There are three types of integers:</p>
<dl class="docutils">
<dt>Plain integers</dt>
<dd>These represent numbers in the range -2147483648 through
2147483647. (The range may be larger on machines with a
larger natural word size, but not smaller.)  When the result
of an operation would fall outside this range, the result is
normally returned as a long integer (in some cases, the
exception <tt class="docutils literal"><span class="pre">OverflowError</span></tt> is raised instead).  For the
purpose of shift and mask operations, integers are assumed to
have a binary, 2&#8217;s complement notation using 32 or more bits,
and hiding no bits from the user (i.e., all 4294967296
different bit patterns correspond to different values).</dd>
<dt>Long integers</dt>
<dd>These represent numbers in an unlimited range, subject to
available (virtual) memory only.  For the purpose of shift
and mask operations, a binary representation is assumed, and
negative numbers are represented in a variant of 2&#8217;s
complement which gives the illusion of an infinite string of
sign bits extending to the left.</dd>
<dt>Booleans</dt>
<dd>These represent the truth values False and True.  The two
objects representing the values False and True are the only
Boolean objects. The Boolean type is a subtype of plain
integers, and Boolean values behave like the values 0 and 1,
respectively, in almost all contexts, the exception being
that when converted to a string, the strings <tt class="docutils literal"><span class="pre">&quot;False&quot;</span></tt> or
<tt class="docutils literal"><span class="pre">&quot;True&quot;</span></tt> are returned, respectively.</dd>
</dl>
<p class="last">The rules for integer representation are intended to give the
most meaningful interpretation of shift and mask operations
involving negative integers and the least surprises when
switching between the plain and long integer domains.  Any
operation, if it yields a result in the plain integer domain,
will yield the same result in the long integer domain or when
using mixed operands.  The switch between domains is transparent
to the programmer.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">numbers.Real</span></tt> (<tt class="docutils literal"><span class="pre">float</span></tt>)</dt>
<dd>These represent machine-level double precision floating point
numbers. You are at the mercy of the underlying machine
architecture (and C or Java implementation) for the accepted
range and handling of overflow. Python does not support single-
precision floating point numbers; the savings in processor and
memory usage that are usually the reason for using these is
dwarfed by the overhead of using objects in Python, so there is
no reason to complicate the language with two kinds of floating
point numbers.</dd>
<dt><tt class="docutils literal"><span class="pre">numbers.Complex</span></tt></dt>
<dd>These represent complex numbers as a pair of machine-level
double precision floating point numbers.  The same caveats apply
as for floating point numbers. The real and imaginary parts of a
complex number <tt class="docutils literal"><span class="pre">z</span></tt> can be retrieved through the read-only
attributes <tt class="docutils literal"><span class="pre">z.real</span></tt> and <tt class="docutils literal"><span class="pre">z.imag</span></tt>.</dd>
</dl>
</dd>
<dt>Sequences</dt>
<dd><p class="first">These represent finite ordered sets indexed by non-negative
numbers. The built-in function <tt class="docutils literal"><span class="pre">len()</span></tt> returns the number of
items of a sequence. When the length of a sequence is <em>n</em>, the
index set contains the numbers 0, 1, ..., <em>n</em>-1.  Item <em>i</em> of
sequence <em>a</em> is selected by <tt class="docutils literal"><span class="pre">a[i]</span></tt>.</p>
<p>Sequences also support slicing: <tt class="docutils literal"><span class="pre">a[i:j]</span></tt> selects all items with
index <em>k</em> such that <em>i</em> <tt class="docutils literal"><span class="pre">&lt;=</span></tt> <em>k</em> <tt class="docutils literal"><span class="pre">&lt;</span></tt> <em>j</em>.  When used as an
expression, a slice is a sequence of the same type.  This implies
that the index set is renumbered so that it starts at 0.</p>
<p>Some sequences also support &#8220;extended slicing&#8221; with a third &#8220;step&#8221;
parameter: <tt class="docutils literal"><span class="pre">a[i:j:k]</span></tt> selects all items of <em>a</em> with index <em>x</em>
where <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></tt>, <em>n</em> <tt class="docutils literal"><span class="pre">&gt;=</span></tt> <tt class="docutils literal"><span class="pre">0</span></tt> and <em>i</em> <tt class="docutils literal"><span class="pre">&lt;=</span></tt> <em>x</em> <tt class="docutils literal"><span class="pre">&lt;</span></tt>
<em>j</em>.</p>
<p>Sequences are distinguished according to their mutability:</p>
<dl class="last docutils">
<dt>Immutable sequences</dt>
<dd><p class="first">An object of an immutable sequence type cannot change once it is
created.  (If the object contains references to other objects,
these other objects may be mutable and may be changed; however,
the collection of objects directly referenced by an immutable
object cannot change.)</p>
<p>The following types are immutable sequences:</p>
<dl class="last docutils">
<dt>Strings</dt>
<dd><p class="first">The items of a string are characters.  There is no separate
character type; a character is represented by a string of one
item. Characters represent (at least) 8-bit bytes.  The
built-in functions <tt class="docutils literal"><span class="pre">chr()</span></tt> and <tt class="docutils literal"><span class="pre">ord()</span></tt> convert between
characters and nonnegative integers representing the byte
values.  Bytes with the values 0-127 usually represent the
corresponding ASCII values, but the interpretation of values
is up to the program.  The string data type is also used to
represent arrays of bytes, e.g., to hold data read from a
file.</p>
<p class="last">(On systems whose native character set is not ASCII, strings
may use EBCDIC in their internal representation, provided the
functions <tt class="docutils literal"><span class="pre">chr()</span></tt> and <tt class="docutils literal"><span class="pre">ord()</span></tt> implement a mapping between
ASCII and EBCDIC, and string comparison preserves the ASCII
order. Or perhaps someone can propose a better rule?)</p>
</dd>
<dt>Unicode</dt>
<dd>The items of a Unicode object are Unicode code units.  A
Unicode code unit is represented by a Unicode object of one
item and can hold either a 16-bit or 32-bit value
representing a Unicode ordinal (the maximum value for the
ordinal is given in <tt class="docutils literal"><span class="pre">sys.maxunicode</span></tt>, and depends on how
Python is configured at compile time).  Surrogate pairs may
be present in the Unicode object, and will be reported as two
separate items.  The built-in functions <tt class="docutils literal"><span class="pre">unichr()</span></tt> and
<tt class="docutils literal"><span class="pre">ord()</span></tt> convert between code units and nonnegative integers
representing the Unicode ordinals as defined in the Unicode
Standard 3.0. Conversion from and to other encodings are
possible through the Unicode method <tt class="docutils literal"><span class="pre">encode()</span></tt> and the
built-in function <tt class="docutils literal"><span class="pre">unicode()</span></tt>.</dd>
<dt>Tuples</dt>
<dd>The items of a tuple are arbitrary Python objects. Tuples of
two or more items are formed by comma-separated lists of
expressions.  A tuple of one item (a &#8216;singleton&#8217;) can be
formed by affixing a comma to an expression (an expression by
itself does not create a tuple, since parentheses must be
usable for grouping of expressions).  An empty tuple can be
formed by an empty pair of parentheses.</dd>
</dl>
</dd>
<dt>Mutable sequences</dt>
<dd><p class="first">Mutable sequences can be changed after they are created.  The
subscription and slicing notations can be used as the target of
assignment and <tt class="docutils literal"><span class="pre">del</span></tt> (delete) statements.</p>
<p>There is currently a single intrinsic mutable sequence type:</p>
<dl class="docutils">
<dt>Lists</dt>
<dd>The items of a list are arbitrary Python objects.  Lists are
formed by placing a comma-separated list of expressions in
square brackets. (Note that there are no special cases needed
to form lists of length 0 or 1.)</dd>
</dl>
<p class="last">The extension module <tt class="docutils literal"><span class="pre">array</span></tt> provides an additional example of
a mutable sequence type.</p>
</dd>
</dl>
</dd>
<dt>Set types</dt>
<dd><p class="first">These represent unordered, finite sets of unique, immutable
objects. As such, they cannot be indexed by any subscript. However,
they can be iterated over, and the built-in function <tt class="docutils literal"><span class="pre">len()</span></tt>
returns the number of items in a set. Common uses for sets are fast
membership testing, removing duplicates from a sequence, and
computing mathematical operations such as intersection, union,
difference, and symmetric difference.</p>
<p>For set elements, the same immutability rules apply as for
dictionary keys. Note that numeric types obey the normal rules for
numeric comparison: if two numbers compare equal (e.g., <tt class="docutils literal"><span class="pre">1</span></tt> and
<tt class="docutils literal"><span class="pre">1.0</span></tt>), only one of them can be contained in a set.</p>
<p>There are currently two intrinsic set types:</p>
<dl class="last docutils">
<dt>Sets</dt>
<dd>These represent a mutable set. They are created by the built-in
<tt class="docutils literal"><span class="pre">set()</span></tt> constructor and can be modified afterwards by several
methods, such as <tt class="docutils literal"><span class="pre">add()</span></tt>.</dd>
<dt>Frozen sets</dt>
<dd>These represent an immutable set.  They are created by the
built-in <tt class="docutils literal"><span class="pre">frozenset()</span></tt> constructor.  As a frozenset is
immutable and <em>hashable</em>, it can be used again as an element of
another set, or as a dictionary key.</dd>
</dl>
</dd>
<dt>Mappings</dt>
<dd><p class="first">These represent finite sets of objects indexed by arbitrary index
sets. The subscript notation <tt class="docutils literal"><span class="pre">a[k]</span></tt> selects the item indexed by
<tt class="docutils literal"><span class="pre">k</span></tt> from the mapping <tt class="docutils literal"><span class="pre">a</span></tt>; this can be used in expressions and
as the target of assignments or <tt class="docutils literal"><span class="pre">del</span></tt> statements. The built-in
function <tt class="docutils literal"><span class="pre">len()</span></tt> returns the number of items in a mapping.</p>
<p>There is currently a single intrinsic mapping type:</p>
<dl class="last docutils">
<dt>Dictionaries</dt>
<dd><p class="first">These represent finite sets of objects indexed by nearly
arbitrary values.  The only types of values not acceptable as
keys are values containing lists or dictionaries or other
mutable types that are compared by value rather than by object
identity, the reason being that the efficient implementation of
dictionaries requires a key&#8217;s hash value to remain constant.
Numeric types used for keys obey the normal rules for numeric
comparison: if two numbers compare equal (e.g., <tt class="docutils literal"><span class="pre">1</span></tt> and
<tt class="docutils literal"><span class="pre">1.0</span></tt>) then they can be used interchangeably to index the same
dictionary entry.</p>
<p>Dictionaries are mutable; they can be created by the <tt class="docutils literal"><span class="pre">{...}</span></tt>
notation (see section <em>Dictionary displays</em>).</p>
<p class="last">The extension modules <tt class="docutils literal"><span class="pre">dbm</span></tt>, <tt class="docutils literal"><span class="pre">gdbm</span></tt>, and <tt class="docutils literal"><span class="pre">bsddb</span></tt> provide
additional examples of mapping types.</p>
</dd>
</dl>
</dd>
<dt>Callable types</dt>
<dd><p class="first">These are the types to which the function call operation (see
section <em>Calls</em>) can be applied:</p>
<dl class="last docutils">
<dt>User-defined functions</dt>
<dd><p class="first">A user-defined function object is created by a function
definition (see section <em>Function definitions</em>).  It should be
called with an argument list containing the same number of items
as the function&#8217;s formal parameter list.</p>
<p>Special attributes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="46%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Attribute</th>
<th class="head">Meaning</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">func_doc</span></tt></td>
<td>The function&#8217;s documentation
string, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if
unavailable</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">__doc__</span></tt></td>
<td>Another way of spelling
<tt class="docutils literal"><span class="pre">func_doc</span></tt></td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_name</span></tt></td>
<td>The function&#8217;s name</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">__name__</span></tt></td>
<td>Another way of spelling
<tt class="docutils literal"><span class="pre">func_name</span></tt></td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">__module__</span></tt></td>
<td>The name of the module the
function was defined in, or
<tt class="xref docutils literal"><span class="pre">None</span></tt> if unavailable.</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_defaults</span></tt></td>
<td>A tuple containing default
argument values for those
arguments that have defaults,
or <tt class="xref docutils literal"><span class="pre">None</span></tt> if no arguments
have a default value</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_code</span></tt></td>
<td>The code object representing
the compiled function body.</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_globals</span></tt></td>
<td>A reference to the dictionary
that holds the function&#8217;s
global variables &#8212; the global
namespace of the module in
which the function was defined.</td>
<td>Read-only</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_dict</span></tt></td>
<td>The namespace supporting
arbitrary function attributes.</td>
<td>Writable</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">func_closure</span></tt></td>
<td><tt class="xref docutils literal"><span class="pre">None</span></tt> or a tuple of cells
that contain bindings for the
function&#8217;s free variables.</td>
<td>Read-only</td>
</tr>
</tbody>
</table>
<p>Most of the attributes labelled &#8220;Writable&#8221; check the type of the
assigned value.</p>
<p>Changed in version 2.4: <tt class="docutils literal"><span class="pre">func_name</span></tt> is now writable.</p>
<p>Function objects also support getting and setting arbitrary
attributes, which can be used, for example, to attach metadata
to functions.  Regular attribute dot-notation is used to get and
set such attributes. <em>Note that the current implementation only
supports function attributes on user-defined functions. Function
attributes on built-in functions may be supported in the
future.</em></p>
<p class="last">Additional information about a function&#8217;s definition can be
retrieved from its code object; see the description of internal
types below.</p>
</dd>
<dt>User-defined methods</dt>
<dd><p class="first">A user-defined method object combines a class, a class instance
(or <tt class="xref docutils literal"><span class="pre">None</span></tt>) and any callable object (normally a user-defined
function).</p>
<p>Special read-only attributes: <tt class="docutils literal"><span class="pre">im_self</span></tt> is the class instance
object, <tt class="docutils literal"><span class="pre">im_func</span></tt> is the function object; <tt class="docutils literal"><span class="pre">im_class</span></tt> is the
class of <tt class="docutils literal"><span class="pre">im_self</span></tt> for bound methods or the class that asked
for the method for unbound methods; <tt class="docutils literal"><span class="pre">__doc__</span></tt> is the method&#8217;s
documentation (same as <tt class="docutils literal"><span class="pre">im_func.__doc__</span></tt>); <tt class="docutils literal"><span class="pre">__name__</span></tt> is the
method name (same as <tt class="docutils literal"><span class="pre">im_func.__name__</span></tt>); <tt class="docutils literal"><span class="pre">__module__</span></tt> is
the name of the module the method was defined in, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if
unavailable.</p>
<p>Changed in version 2.2: <tt class="docutils literal"><span class="pre">im_self</span></tt> used to refer to the class
that defined the method.</p>
<p>Changed in version 2.6: For 3.0 forward-compatibility,
<tt class="docutils literal"><span class="pre">im_func</span></tt> is also available as <tt class="docutils literal"><span class="pre">__func__</span></tt>, and <tt class="docutils literal"><span class="pre">im_self</span></tt>
as <tt class="docutils literal"><span class="pre">__self__</span></tt>.</p>
<p>Methods also support accessing (but not setting) the arbitrary
function attributes on the underlying function object.</p>
<p>User-defined method objects may be created when getting an
attribute of a class (perhaps via an instance of that class), if
that attribute is a user-defined function object, an unbound
user-defined method object, or a class method object. When the
attribute is a user-defined method object, a new method object
is only created if the class from which it is being retrieved is
the same as, or a derived class of, the class stored in the
original method object; otherwise, the original method object is
used as it is.</p>
<p>When a user-defined method object is created by retrieving a
user-defined function object from a class, its <tt class="docutils literal"><span class="pre">im_self</span></tt>
attribute is <tt class="xref docutils literal"><span class="pre">None</span></tt> and the method object is said to be
unbound. When one is created by retrieving a user-defined
function object from a class via one of its instances, its
<tt class="docutils literal"><span class="pre">im_self</span></tt> attribute is the instance, and the method object is
said to be bound. In either case, the new method&#8217;s <tt class="docutils literal"><span class="pre">im_class</span></tt>
attribute is the class from which the retrieval takes place, and
its <tt class="docutils literal"><span class="pre">im_func</span></tt> attribute is the original function object.</p>
<p>When a user-defined method object is created by retrieving
another method object from a class or instance, the behaviour is
the same as for a function object, except that the <tt class="docutils literal"><span class="pre">im_func</span></tt>
attribute of the new instance is not the original method object
but its <tt class="docutils literal"><span class="pre">im_func</span></tt> attribute.</p>
<p>When a user-defined method object is created by retrieving a
class method object from a class or instance, its <tt class="docutils literal"><span class="pre">im_self</span></tt>
attribute is the class itself (the same as the <tt class="docutils literal"><span class="pre">im_class</span></tt>
attribute), and its <tt class="docutils literal"><span class="pre">im_func</span></tt> attribute is the function object
underlying the class method.</p>
<p>When an unbound user-defined method object is called, the
underlying function (<tt class="docutils literal"><span class="pre">im_func</span></tt>) is called, with the
restriction that the first argument must be an instance of the
proper class (<tt class="docutils literal"><span class="pre">im_class</span></tt>) or of a derived class thereof.</p>
<p>When a bound user-defined method object is called, the
underlying function (<tt class="docutils literal"><span class="pre">im_func</span></tt>) is called, inserting the class
instance (<tt class="docutils literal"><span class="pre">im_self</span></tt>) in front of the argument list.  For
instance, when <tt class="docutils literal"><span class="pre">C</span></tt> is a class which contains a definition for
a function <tt class="docutils literal"><span class="pre">f()</span></tt>, and <tt class="docutils literal"><span class="pre">x</span></tt> is an instance of <tt class="docutils literal"><span class="pre">C</span></tt>, calling
<tt class="docutils literal"><span class="pre">x.f(1)</span></tt> is equivalent to calling <tt class="docutils literal"><span class="pre">C.f(x,</span> <span class="pre">1)</span></tt>.</p>
<p>When a user-defined method object is derived from a class method
object, the &#8220;class instance&#8221; stored in <tt class="docutils literal"><span class="pre">im_self</span></tt> will actually
be the class itself, so that calling either <tt class="docutils literal"><span class="pre">x.f(1)</span></tt> or
<tt class="docutils literal"><span class="pre">C.f(1)</span></tt> is equivalent to calling <tt class="docutils literal"><span class="pre">f(C,1)</span></tt> where <tt class="docutils literal"><span class="pre">f</span></tt> is
the underlying function.</p>
<p class="last">Note that the transformation from function object to (unbound or
bound) method object happens each time the attribute is
retrieved from the class or instance. In some cases, a fruitful
optimization is to assign the attribute to a local variable and
call that local variable. Also notice that this transformation
only happens for user-defined functions; other callable objects
(and all non-callable objects) are retrieved without
transformation.  It is also important to note that user-defined
functions which are attributes of a class instance are not
converted to bound methods; this <em>only</em> happens when the
function is an attribute of the class.</p>
</dd>
<dt>Generator functions</dt>
<dd>A function or method which uses the <tt class="docutils literal"><span class="pre">yield</span></tt> statement (see
section <em>The yield statement</em>) is called a <em>generator function</em>.
Such a function, when called, always returns an iterator object
which can be used to execute the body of the function:  calling
the iterator&#8217;s <tt class="docutils literal"><span class="pre">next()</span></tt> method will cause the function to
execute until it provides a value using the <tt class="docutils literal"><span class="pre">yield</span></tt> statement.
When the function executes a <tt class="docutils literal"><span class="pre">return</span></tt> statement or falls off
the end, a <tt class="docutils literal"><span class="pre">StopIteration</span></tt> exception is raised and the
iterator will have reached the end of the set of values to be
returned.</dd>
<dt>Built-in functions</dt>
<dd>A built-in function object is a wrapper around a C function.
Examples of built-in functions are <tt class="docutils literal"><span class="pre">len()</span></tt> and <tt class="docutils literal"><span class="pre">math.sin()</span></tt>
(<tt class="docutils literal"><span class="pre">math</span></tt> is a standard built-in module). The number and type of
the arguments are determined by the C function. Special read-
only attributes: <tt class="docutils literal"><span class="pre">__doc__</span></tt> is the function&#8217;s documentation
string, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if unavailable; <tt class="docutils literal"><span class="pre">__name__</span></tt> is the
function&#8217;s name; <tt class="docutils literal"><span class="pre">__self__</span></tt> is set to <tt class="xref docutils literal"><span class="pre">None</span></tt> (but see the
next item); <tt class="docutils literal"><span class="pre">__module__</span></tt> is the name of the module the
function was defined in or <tt class="xref docutils literal"><span class="pre">None</span></tt> if unavailable.</dd>
<dt>Built-in methods</dt>
<dd>This is really a different disguise of a built-in function, this
time containing an object passed to the C function as an
implicit extra argument.  An example of a built-in method is
<tt class="docutils literal"><span class="pre">alist.append()</span></tt>, assuming <em>alist</em> is a list object. In this
case, the special read-only attribute <tt class="docutils literal"><span class="pre">__self__</span></tt> is set to the
object denoted by <em>list</em>.</dd>
<dt>Class Types</dt>
<dd>Class types, or &#8220;new-style classes,&#8221; are callable.  These
objects normally act as factories for new instances of
themselves, but variations are possible for class types that
override <tt class="docutils literal"><span class="pre">__new__()</span></tt>.  The arguments of the call are passed to
<tt class="docutils literal"><span class="pre">__new__()</span></tt> and, in the typical case, to <tt class="docutils literal"><span class="pre">__init__()</span></tt> to
initialize the new instance.</dd>
<dt>Classic Classes</dt>
<dd>Class objects are described below.  When a class object is
called, a new class instance (also described below) is created
and returned.  This implies a call to the class&#8217;s <tt class="docutils literal"><span class="pre">__init__()</span></tt>
method if it has one.  Any arguments are passed on to the
<tt class="docutils literal"><span class="pre">__init__()</span></tt> method.  If there is no <tt class="docutils literal"><span class="pre">__init__()</span></tt> method,
the class must be called without arguments.</dd>
<dt>Class instances</dt>
<dd>Class instances are described below.  Class instances are
callable only when the class has a <tt class="docutils literal"><span class="pre">__call__()</span></tt> method;
<tt class="docutils literal"><span class="pre">x(arguments)</span></tt> is a shorthand for <tt class="docutils literal"><span class="pre">x.__call__(arguments)</span></tt>.</dd>
</dl>
</dd>
<dt>Modules</dt>
<dd><p class="first">Modules are imported by the <tt class="docutils literal"><span class="pre">import</span></tt> statement (see section <em>The
import statement</em>). A module object has a namespace implemented by
a dictionary object (this is the dictionary referenced by the
func_globals attribute of functions defined in the module).
Attribute references are translated to lookups in this dictionary,
e.g., <tt class="docutils literal"><span class="pre">m.x</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span></tt>. A module object
does not contain the code object used to initialize the module
(since it isn&#8217;t needed once the initialization is done).</p>
<p>Attribute assignment updates the module&#8217;s namespace dictionary,
e.g., <tt class="docutils literal"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></tt>.</p>
<p>Special read-only attribute: <tt class="docutils literal"><span class="pre">__dict__</span></tt> is the module&#8217;s namespace
as a dictionary object.</p>
<p class="last">Predefined (writable) attributes: <tt class="docutils literal"><span class="pre">__name__</span></tt> is the module&#8217;s
name; <tt class="docutils literal"><span class="pre">__doc__</span></tt> is the module&#8217;s documentation string, or <tt class="xref docutils literal"><span class="pre">None</span></tt>
if unavailable; <tt class="docutils literal"><span class="pre">__file__</span></tt> is the pathname of the file from which
the module was loaded, if it was loaded from a file. The
<tt class="docutils literal"><span class="pre">__file__</span></tt> attribute is not present for C modules that are
statically linked into the interpreter; for extension modules
loaded dynamically from a shared library, it is the pathname of the
shared library file.</p>
</dd>
<dt>Classes</dt>
<dd><p class="first">Both class types (new-style classes) and class objects (old-
style/classic classes) are typically created by class definitions
(see section <em>Class definitions</em>).  A class has a namespace
implemented by a dictionary object. Class attribute references are
translated to lookups in this dictionary, e.g., <tt class="docutils literal"><span class="pre">C.x</span></tt> is
translated to <tt class="docutils literal"><span class="pre">C.__dict__[&quot;x&quot;]</span></tt> (although for new-style classes
in particular there are a number of hooks which allow for other
means of locating attributes). When the attribute name is not found
there, the attribute search continues in the base classes.  For
old-style classes, the search is depth-first, left-to-right in the
order of occurrence in the base class list. New-style classes use
the more complex C3 method resolution order which behaves correctly
even in the presence of &#8216;diamond&#8217; inheritance structures where
there are multiple inheritance paths leading back to a common
ancestor. Additional details on the C3 MRO used by new-style
classes can be found in the documentation accompanying the 2.3
release at <a class="reference external" href="http://www.python.org/download/releases/2.3/mro/">http://www.python.org/download/releases/2.3/mro/</a>.</p>
<p>When a class attribute reference (for class <tt class="docutils literal"><span class="pre">C</span></tt>, say) would yield
a user-defined function object or an unbound user-defined method
object whose associated class is either <tt class="docutils literal"><span class="pre">C</span></tt> or one of its base
classes, it is transformed into an unbound user-defined method
object whose <tt class="docutils literal"><span class="pre">im_class</span></tt> attribute is <tt class="docutils literal"><span class="pre">C</span></tt>. When it would yield a
class method object, it is transformed into a bound user-defined
method object whose <tt class="docutils literal"><span class="pre">im_class</span></tt> and <tt class="docutils literal"><span class="pre">im_self</span></tt> attributes are
both <tt class="docutils literal"><span class="pre">C</span></tt>.  When it would yield a static method object, it is
transformed into the object wrapped by the static method object.
See section <em>Implementing Descriptors</em> for another way in which
attributes retrieved from a class may differ from those actually
contained in its <tt class="docutils literal"><span class="pre">__dict__</span></tt> (note that only new-style classes
support descriptors).</p>
<p>Class attribute assignments update the class&#8217;s dictionary, never
the dictionary of a base class.</p>
<p>A class object can be called (see above) to yield a class instance
(see below).</p>
<p class="last">Special attributes: <tt class="docutils literal"><span class="pre">__name__</span></tt> is the class name; <tt class="docutils literal"><span class="pre">__module__</span></tt>
is the module name in which the class was defined; <tt class="docutils literal"><span class="pre">__dict__</span></tt> is
the dictionary containing the class&#8217;s namespace; <tt class="docutils literal"><span class="pre">__bases__</span></tt> is a
tuple (possibly empty or a singleton) containing the base classes,
in the order of their occurrence in the base class list;
<tt class="docutils literal"><span class="pre">__doc__</span></tt> is the class&#8217;s documentation string, or None if
undefined.</p>
</dd>
<dt>Class instances</dt>
<dd><p class="first">A class instance is created by calling a class object (see above).
A class instance has a namespace implemented as a dictionary which
is the first place in which attribute references are searched.
When an attribute is not found there, and the instance&#8217;s class has
an attribute by that name, the search continues with the class
attributes.  If a class attribute is found that is a user-defined
function object or an unbound user-defined method object whose
associated class is the class (call it <tt class="docutils literal"><span class="pre">C</span></tt>) of the instance for
which the attribute reference was initiated or one of its bases, it
is transformed into a bound user-defined method object whose
<tt class="docutils literal"><span class="pre">im_class</span></tt> attribute is <tt class="docutils literal"><span class="pre">C</span></tt> and whose <tt class="docutils literal"><span class="pre">im_self</span></tt> attribute is
the instance. Static method and class method objects are also
transformed, as if they had been retrieved from class <tt class="docutils literal"><span class="pre">C</span></tt>; see
above under &#8220;Classes&#8221;. See section <em>Implementing Descriptors</em> for
another way in which attributes of a class retrieved via its
instances may differ from the objects actually stored in the
class&#8217;s <tt class="docutils literal"><span class="pre">__dict__</span></tt>. If no class attribute is found, and the
object&#8217;s class has a <tt class="docutils literal"><span class="pre">__getattr__()</span></tt> method, that is called to
satisfy the lookup.</p>
<p>Attribute assignments and deletions update the instance&#8217;s
dictionary, never a class&#8217;s dictionary.  If the class has a
<tt class="docutils literal"><span class="pre">__setattr__()</span></tt> or <tt class="docutils literal"><span class="pre">__delattr__()</span></tt> method, this is called
instead of updating the instance dictionary directly.</p>
<p>Class instances can pretend to be numbers, sequences, or mappings
if they have methods with certain special names.  See section
<em>Special method names</em>.</p>
<p class="last">Special attributes: <tt class="docutils literal"><span class="pre">__dict__</span></tt> is the attribute dictionary;
<tt class="docutils literal"><span class="pre">__class__</span></tt> is the instance&#8217;s class.</p>
</dd>
<dt>Files</dt>
<dd>A file object represents an open file.  File objects are created by
the <tt class="docutils literal"><span class="pre">open()</span></tt> built-in function, and also by <tt class="docutils literal"><span class="pre">os.popen()</span></tt>,
<tt class="docutils literal"><span class="pre">os.fdopen()</span></tt>, and the <tt class="docutils literal"><span class="pre">makefile()</span></tt> method of socket objects
(and perhaps by other functions or methods provided by extension
modules).  The objects <tt class="docutils literal"><span class="pre">sys.stdin</span></tt>, <tt class="docutils literal"><span class="pre">sys.stdout</span></tt> and
<tt class="docutils literal"><span class="pre">sys.stderr</span></tt> are initialized to file objects corresponding to the
interpreter&#8217;s standard input, output and error streams.  See <em>File
Objects</em> for complete documentation of file objects.</dd>
<dt>Internal types</dt>
<dd><p class="first">A few types used internally by the interpreter are exposed to the
user. Their definitions may change with future versions of the
interpreter, but they are mentioned here for completeness.</p>
<dl class="last docutils">
<dt>Code objects</dt>
<dd><p class="first">Code objects represent <em>byte-compiled</em> executable Python code,
or <em>bytecode</em>. The difference between a code object and a
function object is that the function object contains an explicit
reference to the function&#8217;s globals (the module in which it was
defined), while a code object contains no context; also the
default argument values are stored in the function object, not
in the code object (because they represent values calculated at
run-time).  Unlike function objects, code objects are immutable
and contain no references (directly or indirectly) to mutable
objects.</p>
<p>Special read-only attributes: <tt class="docutils literal"><span class="pre">co_name</span></tt> gives the function
name; <tt class="docutils literal"><span class="pre">co_argcount</span></tt> is the number of positional arguments
(including arguments with default values); <tt class="docutils literal"><span class="pre">co_nlocals</span></tt> is the
number of local variables used by the function (including
arguments); <tt class="docutils literal"><span class="pre">co_varnames</span></tt> is a tuple containing the names of
the local variables (starting with the argument names);
<tt class="docutils literal"><span class="pre">co_cellvars</span></tt> is a tuple containing the names of local
variables that are referenced by nested functions;
<tt class="docutils literal"><span class="pre">co_freevars</span></tt> is a tuple containing the names of free
variables; <tt class="docutils literal"><span class="pre">co_code</span></tt> is a string representing the sequence of
bytecode instructions; <tt class="docutils literal"><span class="pre">co_consts</span></tt> is a tuple containing the
literals used by the bytecode; <tt class="docutils literal"><span class="pre">co_names</span></tt> is a tuple
containing the names used by the bytecode; <tt class="docutils literal"><span class="pre">co_filename</span></tt> is
the filename from which the code was compiled;
<tt class="docutils literal"><span class="pre">co_firstlineno</span></tt> is the first line number of the function;
<tt class="docutils literal"><span class="pre">co_lnotab</span></tt> is a string encoding the mapping from bytecode
offsets to line numbers (for details see the source code of the
interpreter); <tt class="docutils literal"><span class="pre">co_stacksize</span></tt> is the required stack size
(including local variables); <tt class="docutils literal"><span class="pre">co_flags</span></tt> is an integer encoding
a number of flags for the interpreter.</p>
<p>The following flag bits are defined for <tt class="docutils literal"><span class="pre">co_flags</span></tt>: bit
<tt class="docutils literal"><span class="pre">0x04</span></tt> is set if the function uses the <tt class="docutils literal"><span class="pre">*arguments</span></tt> syntax
to accept an arbitrary number of positional arguments; bit
<tt class="docutils literal"><span class="pre">0x08</span></tt> is set if the function uses the <tt class="docutils literal"><span class="pre">**keywords</span></tt> syntax
to accept arbitrary keyword arguments; bit <tt class="docutils literal"><span class="pre">0x20</span></tt> is set if
the function is a generator.</p>
<p>Future feature declarations (<tt class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span>
<span class="pre">division</span></tt>) also use bits in <tt class="docutils literal"><span class="pre">co_flags</span></tt> to indicate whether a
code object was compiled with a particular feature enabled: bit
<tt class="docutils literal"><span class="pre">0x2000</span></tt> is set if the function was compiled with future
division enabled; bits <tt class="docutils literal"><span class="pre">0x10</span></tt> and <tt class="docutils literal"><span class="pre">0x1000</span></tt> were used in
earlier versions of Python.</p>
<p>Other bits in <tt class="docutils literal"><span class="pre">co_flags</span></tt> are reserved for internal use.</p>
<p class="last">If a code object represents a function, the first item in
<tt class="docutils literal"><span class="pre">co_consts</span></tt> is the documentation string of the function, or
<tt class="xref docutils literal"><span class="pre">None</span></tt> if undefined.</p>
</dd>
<dt>Frame objects</dt>
<dd><p class="first">Frame objects represent execution frames.  They may occur in
traceback objects (see below).</p>
<p>Special read-only attributes: <tt class="docutils literal"><span class="pre">f_back</span></tt> is to the previous
stack frame (towards the caller), or <tt class="xref docutils literal"><span class="pre">None</span></tt> if this is the
bottom stack frame; <tt class="docutils literal"><span class="pre">f_code</span></tt> is the code object being executed
in this frame; <tt class="docutils literal"><span class="pre">f_locals</span></tt> is the dictionary used to look up
local variables; <tt class="docutils literal"><span class="pre">f_globals</span></tt> is used for global variables;
<tt class="docutils literal"><span class="pre">f_builtins</span></tt> is used for built-in (intrinsic) names;
<tt class="docutils literal"><span class="pre">f_restricted</span></tt> is a flag indicating whether the function is
executing in restricted execution mode; <tt class="docutils literal"><span class="pre">f_lasti</span></tt> gives the
precise instruction (this is an index into the bytecode string
of the code object).</p>
<p class="last">Special writable attributes: <tt class="docutils literal"><span class="pre">f_trace</span></tt>, if not <tt class="xref docutils literal"><span class="pre">None</span></tt>, is a
function called at the start of each source code line (this is
used by the debugger); <tt class="docutils literal"><span class="pre">f_exc_type</span></tt>, <tt class="docutils literal"><span class="pre">f_exc_value</span></tt>,
<tt class="docutils literal"><span class="pre">f_exc_traceback</span></tt> represent the last exception raised in the
parent frame provided another exception was ever raised in the
current frame (in all other cases they are None); <tt class="docutils literal"><span class="pre">f_lineno</span></tt>
is the current line number of the frame &#8212; writing to this from
within a trace function jumps to the given line (only for the
bottom-most frame).  A debugger can implement a Jump command
(aka Set Next Statement) by writing to f_lineno.</p>
</dd>
<dt>Traceback objects</dt>
<dd><p class="first">Traceback objects represent a stack trace of an exception.  A
traceback object is created when an exception occurs.  When the
search for an exception handler unwinds the execution stack, at
each unwound level a traceback object is inserted in front of
the current traceback.  When an exception handler is entered,
the stack trace is made available to the program. (See section
<em>The try statement</em>.) It is accessible as <tt class="docutils literal"><span class="pre">sys.exc_traceback</span></tt>,
and also as the third item of the tuple returned by
<tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt>.  The latter is the preferred interface,
since it works correctly when the program is using multiple
threads. When the program contains no suitable handler, the
stack trace is written (nicely formatted) to the standard error
stream; if the interpreter is interactive, it is also made
available to the user as <tt class="docutils literal"><span class="pre">sys.last_traceback</span></tt>.</p>
<p class="last">Special read-only attributes: <tt class="docutils literal"><span class="pre">tb_next</span></tt> is the next level in
the stack trace (towards the frame where the exception
occurred), or <tt class="xref docutils literal"><span class="pre">None</span></tt> if there is no next level; <tt class="docutils literal"><span class="pre">tb_frame</span></tt>
points to the execution frame of the current level;
<tt class="docutils literal"><span class="pre">tb_lineno</span></tt> gives the line number where the exception
occurred; <tt class="docutils literal"><span class="pre">tb_lasti</span></tt> indicates the precise instruction.  The
line number and last instruction in the traceback may differ
from the line number of its frame object if the exception
occurred in a <tt class="docutils literal"><span class="pre">try</span></tt> statement with no matching except clause
or with a finally clause.</p>
</dd>
<dt>Slice objects</dt>
<dd><p class="first">Slice objects are used to represent slices when <em>extended slice
syntax</em> is used. This is a slice using two colons, or multiple
slices or ellipses separated by commas, e.g., <tt class="docutils literal"><span class="pre">a[i:j:step]</span></tt>,
<tt class="docutils literal"><span class="pre">a[i:j,</span> <span class="pre">k:l]</span></tt>, or <tt class="docutils literal"><span class="pre">a[...,</span> <span class="pre">i:j]</span></tt>.  They are also created by
the built-in <tt class="docutils literal"><span class="pre">slice()</span></tt> function.</p>
<p>Special read-only attributes: <tt class="docutils literal"><span class="pre">start</span></tt> is the lower bound;
<tt class="docutils literal"><span class="pre">stop</span></tt> is the upper bound; <tt class="docutils literal"><span class="pre">step</span></tt> is the step value; each is
<tt class="xref docutils literal"><span class="pre">None</span></tt> if omitted. These attributes can have any type.</p>
<p>Slice objects support one method:</p>
<p>slice.indices(self, length)</p>
<blockquote class="last">
<p>This method takes a single integer argument <em>length</em> and
computes information about the extended slice that the slice
object would describe if applied to a sequence of <em>length</em>
items.  It returns a tuple of three integers; respectively
these are the <em>start</em> and <em>stop</em> indices and the <em>step</em> or
stride length of the slice. Missing or out-of-bounds indices
are handled in a manner consistent with regular slices.</p>
<p>New in version 2.3.</p>
</blockquote>
</dd>
<dt>Static method objects</dt>
<dd>Static method objects provide a way of defeating the
transformation of function objects to method objects described
above. A static method object is a wrapper around any other
object, usually a user-defined method object. When a static
method object is retrieved from a class or a class instance, the
object actually returned is the wrapped object, which is not
subject to any further transformation. Static method objects are
not themselves callable, although the objects they wrap usually
are. Static method objects are created by the built-in
<tt class="docutils literal"><span class="pre">staticmethod()</span></tt> constructor.</dd>
<dt>Class method objects</dt>
<dd>A class method object, like a static method object, is a wrapper
around another object that alters the way in which that object
is retrieved from classes and class instances. The behaviour of
class method objects upon such retrieval is described above,
under &#8220;User-defined methods&#8221;. Class method objects are created
by the built-in <tt class="docutils literal"><span class="pre">classmethod()</span></tt> constructor.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="new-style-and-classic-classes">
<h2>3.3. New-style and classic classes<a class="headerlink" href="#new-style-and-classic-classes" title="Permalink to this headline">¶</a></h2>
<p>Classes and instances come in two flavors: old-style (or classic) and
new-style.</p>
<p>Up to Python 2.1, old-style classes were the only flavour available to
the user. The concept of (old-style) class is unrelated to the concept
of type: if <em>x</em> is an instance of an old-style class, then
<tt class="docutils literal"><span class="pre">x.__class__</span></tt> designates the class of <em>x</em>, but <tt class="docutils literal"><span class="pre">type(x)</span></tt> is always
<tt class="docutils literal"><span class="pre">&lt;type</span> <span class="pre">'instance'&gt;</span></tt>.  This reflects the fact that all old-style
instances, independently of their class, are implemented with a single
built-in type, called <tt class="docutils literal"><span class="pre">instance</span></tt>.</p>
<p>New-style classes were introduced in Python 2.2 to unify classes and
types.  A new-style class is neither more nor less than a user-defined
type.  If <em>x</em> is an instance of a new-style class, then <tt class="docutils literal"><span class="pre">type(x)</span></tt> is
typically the same as <tt class="docutils literal"><span class="pre">x.__class__</span></tt> (although this is not guaranteed
- a new-style class instance is permitted to override the value
returned for <tt class="docutils literal"><span class="pre">x.__class__</span></tt>).</p>
<p>The major motivation for introducing new-style classes is to provide a
unified object model with a full meta-model.  It also has a number of
practical benefits, like the ability to subclass most built-in types,
or the introduction of &#8220;descriptors&#8221;, which enable computed
properties.</p>
<p>For compatibility reasons, classes are still old-style by default.
New-style classes are created by specifying another new-style class
(i.e. a type) as a parent class, or the &#8220;top-level type&#8221; <tt class="docutils literal"><span class="pre">object</span></tt> if
no other parent is needed.  The behaviour of new-style classes differs
from that of old-style classes in a number of important details in
addition to what <tt class="docutils literal"><span class="pre">type()</span></tt> returns.  Some of these changes are
fundamental to the new object model, like the way special methods are
invoked.  Others are &#8220;fixes&#8221; that could not be implemented before for
compatibility concerns, like the method resolution order in case of
multiple inheritance.</p>
<p>While this manual aims to provide comprehensive coverage of Python&#8217;s
class mechanics, it may still be lacking in some areas when it comes
to its coverage of new-style classes. Please see
<a class="reference external" href="http://www.python.org/doc/newstyle/">http://www.python.org/doc/newstyle/</a> for sources of additional
information.</p>
<p>Old-style classes are removed in Python 3.0, leaving only the
semantics of new-style classes.</p>
</div>
<div class="section" id="special-method-names">
<h2>3.4. Special method names<a class="headerlink" href="#special-method-names" title="Permalink to this headline">¶</a></h2>
<p>A class can implement certain operations that are invoked by special
syntax (such as arithmetic operations or subscripting and slicing) by
defining methods with special names. This is Python&#8217;s approach to
<em>operator overloading</em>, allowing classes to define their own behavior
with respect to language operators.  For instance, if a class defines
a method named <tt class="docutils literal"><span class="pre">__getitem__()</span></tt>, and <tt class="docutils literal"><span class="pre">x</span></tt> is an instance of this
class, then <tt class="docutils literal"><span class="pre">x[i]</span></tt> is roughly equivalent to <tt class="docutils literal"><span class="pre">x.__getitem__(i)</span></tt> for
old-style classes and <tt class="docutils literal"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></tt> for new-style
classes.  Except where mentioned, attempts to execute an operation
raise an exception when no appropriate method is defined (typically
<tt class="docutils literal"><span class="pre">AttributeError</span></tt> or <tt class="docutils literal"><span class="pre">TypeError</span></tt>).</p>
<p>When implementing a class that emulates any built-in type, it is
important that the emulation only be implemented to the degree that it
makes sense for the object being modelled.  For example, some
sequences may work well with retrieval of individual elements, but
extracting a slice may not make sense.  (One example of this is the
<tt class="docutils literal"><span class="pre">NodeList</span></tt> interface in the W3C&#8217;s Document Object Model.)</p>
<div class="section" id="basic-customization">
<h3>3.4.1. Basic customization<a class="headerlink" href="#basic-customization" title="Permalink to this headline">¶</a></h3>
<p>object.__new__(cls[, ...])</p>
<blockquote>
<p>Called to create a new instance of class <em>cls</em>.  <tt class="docutils literal"><span class="pre">__new__()</span></tt> is a
static method (special-cased so you need not declare it as such)
that takes the class of which an instance was requested as its
first argument.  The remaining arguments are those passed to the
object constructor expression (the call to the class).  The return
value of <tt class="docutils literal"><span class="pre">__new__()</span></tt> should be the new object instance (usually
an instance of <em>cls</em>).</p>
<p>Typical implementations create a new instance of the class by
invoking the superclass&#8217;s <tt class="docutils literal"><span class="pre">__new__()</span></tt> method using
<tt class="docutils literal"><span class="pre">super(currentclass,</span> <span class="pre">cls).__new__(cls[,</span> <span class="pre">...])</span></tt> with appropriate
arguments and then modifying the newly-created instance as
necessary before returning it.</p>
<p>If <tt class="docutils literal"><span class="pre">__new__()</span></tt> returns an instance of <em>cls</em>, then the new
instance&#8217;s <tt class="docutils literal"><span class="pre">__init__()</span></tt> method will be invoked like
<tt class="docutils literal"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></tt>, where <em>self</em> is the new instance and the
remaining arguments are the same as were passed to <tt class="docutils literal"><span class="pre">__new__()</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">__new__()</span></tt> does not return an instance of <em>cls</em>, then the new
instance&#8217;s <tt class="docutils literal"><span class="pre">__init__()</span></tt> method will not be invoked.</p>
<p><tt class="docutils literal"><span class="pre">__new__()</span></tt> is intended mainly to allow subclasses of immutable
types (like int, str, or tuple) to customize instance creation.  It
is also commonly overridden in custom metaclasses in order to
customize class creation.</p>
</blockquote>
<p>object.__init__(self[, ...])</p>
<blockquote>
Called when the instance is created.  The arguments are those
passed to the class constructor expression.  If a base class has an
<tt class="docutils literal"><span class="pre">__init__()</span></tt> method, the derived class&#8217;s <tt class="docutils literal"><span class="pre">__init__()</span></tt> method,
if any, must explicitly call it to ensure proper initialization of
the base class part of the instance; for example:
<tt class="docutils literal"><span class="pre">BaseClass.__init__(self,</span> <span class="pre">[args...])</span></tt>.  As a special constraint
on constructors, no value may be returned; doing so will cause a
<tt class="docutils literal"><span class="pre">TypeError</span></tt> to be raised at runtime.</blockquote>
<p>object.__del__(self)</p>
<blockquote>
<p>Called when the instance is about to be destroyed.  This is also
called a destructor.  If a base class has a <tt class="docutils literal"><span class="pre">__del__()</span></tt> method,
the derived class&#8217;s <tt class="docutils literal"><span class="pre">__del__()</span></tt> method, if any, must explicitly
call it to ensure proper deletion of the base class part of the
instance.  Note that it is possible (though not recommended!) for
the <tt class="docutils literal"><span class="pre">__del__()</span></tt> method to postpone destruction of the instance by
creating a new reference to it.  It may then be called at a later
time when this new reference is deleted.  It is not guaranteed that
<tt class="docutils literal"><span class="pre">__del__()</span></tt> methods are called for objects that still exist when
the interpreter exits.</p>
<dl class="docutils">
<dt>Note: <tt class="docutils literal"><span class="pre">del</span> <span class="pre">x</span></tt> doesn&#8217;t directly call <tt class="docutils literal"><span class="pre">x.__del__()</span></tt> &#8212; the former</dt>
<dd>decrements the reference count for <tt class="docutils literal"><span class="pre">x</span></tt> by one, and the latter
is only called when <tt class="docutils literal"><span class="pre">x</span></tt>&#8216;s reference count reaches zero.  Some
common situations that may prevent the reference count of an
object from going to zero include: circular references between
objects (e.g., a doubly-linked list or a tree data structure with
parent and child pointers); a reference to the object on the
stack frame of a function that caught an exception (the traceback
stored in <tt class="docutils literal"><span class="pre">sys.exc_traceback</span></tt> keeps the stack frame alive); or
a reference to the object on the stack frame that raised an
unhandled exception in interactive mode (the traceback stored in
<tt class="docutils literal"><span class="pre">sys.last_traceback</span></tt> keeps the stack frame alive).  The first
situation can only be remedied by explicitly breaking the cycles;
the latter two situations can be resolved by storing <tt class="xref docutils literal"><span class="pre">None</span></tt> in
<tt class="docutils literal"><span class="pre">sys.exc_traceback</span></tt> or <tt class="docutils literal"><span class="pre">sys.last_traceback</span></tt>.  Circular
references which are garbage are detected when the option cycle
detector is enabled (it&#8217;s on by default), but can only be cleaned
up if there are no Python-level <tt class="docutils literal"><span class="pre">__del__()</span></tt> methods involved.
Refer to the documentation for the <tt class="docutils literal"><span class="pre">gc</span></tt> module for more
information about how <tt class="docutils literal"><span class="pre">__del__()</span></tt> methods are handled by the
cycle detector, particularly the description of the <tt class="docutils literal"><span class="pre">garbage</span></tt>
value.</dd>
<dt>Warning: Due to the precarious circumstances under which <tt class="docutils literal"><span class="pre">__del__()</span></tt></dt>
<dd>methods are invoked, exceptions that occur during their execution
are ignored, and a warning is printed to <tt class="docutils literal"><span class="pre">sys.stderr</span></tt> instead.
Also, when <tt class="docutils literal"><span class="pre">__del__()</span></tt> is invoked in response to a module being
deleted (e.g., when execution of the program is done), other
globals referenced by the <tt class="docutils literal"><span class="pre">__del__()</span></tt> method may already have
been deleted or in the process of being torn down (e.g. the
import machinery shutting down).  For this reason, <tt class="docutils literal"><span class="pre">__del__()</span></tt>
methods should do the absolute minimum needed to maintain
external invariants.  Starting with version 1.5, Python
guarantees that globals whose name begins with a single
underscore are deleted from their module before other globals are
deleted; if no other references to such globals exist, this may
help in assuring that imported modules are still available at the
time when the <tt class="docutils literal"><span class="pre">__del__()</span></tt> method is called.</dd>
</dl>
</blockquote>
<p>object.__repr__(self)</p>
<blockquote>
<p>Called by the <tt class="docutils literal"><span class="pre">repr()</span></tt> built-in function and by string
conversions (reverse quotes) to compute the &#8220;official&#8221; string
representation of an object.  If at all possible, this should look
like a valid Python expression that could be used to recreate an
object with the same value (given an appropriate environment).  If
this is not possible, a string of the form <tt class="docutils literal"><span class="pre">&lt;...some</span> <span class="pre">useful</span>
<span class="pre">description...&gt;</span></tt> should be returned.  The return value must be a
string object. If a class defines <tt class="docutils literal"><span class="pre">__repr__()</span></tt> but not
<tt class="docutils literal"><span class="pre">__str__()</span></tt>, then <tt class="docutils literal"><span class="pre">__repr__()</span></tt> is also used when an &#8220;informal&#8221;
string representation of instances of that class is required.</p>
<p>This is typically used for debugging, so it is important that the
representation is information-rich and unambiguous.</p>
</blockquote>
<p>object.__str__(self)</p>
<blockquote>
Called by the <tt class="docutils literal"><span class="pre">str()</span></tt> built-in function and by the <tt class="docutils literal"><span class="pre">print</span></tt>
statement to compute the &#8220;informal&#8221; string representation of an
object.  This differs from <tt class="docutils literal"><span class="pre">__repr__()</span></tt> in that it does not have
to be a valid Python expression: a more convenient or concise
representation may be used instead. The return value must be a
string object.</blockquote>
<p>object.__lt__(self, other)
object.__le__(self, other)
object.__eq__(self, other)
object.__ne__(self, other)
object.__gt__(self, other)
object.__ge__(self, other)</p>
<blockquote>
<p>New in version 2.1.</p>
<p>These are the so-called &#8220;rich comparison&#8221; methods, and are called
for comparison operators in preference to <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> below. The
correspondence between operator symbols and method names is as
follows: <tt class="docutils literal"><span class="pre">x&lt;y</span></tt> calls <tt class="docutils literal"><span class="pre">x.__lt__(y)</span></tt>, <tt class="docutils literal"><span class="pre">x&lt;=y</span></tt> calls
<tt class="docutils literal"><span class="pre">x.__le__(y)</span></tt>, <tt class="docutils literal"><span class="pre">x==y</span></tt> calls <tt class="docutils literal"><span class="pre">x.__eq__(y)</span></tt>, <tt class="docutils literal"><span class="pre">x!=y</span></tt> and
<tt class="docutils literal"><span class="pre">x&lt;&gt;y</span></tt> call <tt class="docutils literal"><span class="pre">x.__ne__(y)</span></tt>, <tt class="docutils literal"><span class="pre">x&gt;y</span></tt> calls <tt class="docutils literal"><span class="pre">x.__gt__(y)</span></tt>, and
<tt class="docutils literal"><span class="pre">x&gt;=y</span></tt> calls <tt class="docutils literal"><span class="pre">x.__ge__(y)</span></tt>.</p>
<p>A rich comparison method may return the singleton
<tt class="docutils literal"><span class="pre">NotImplemented</span></tt> if it does not implement the operation for a
given pair of arguments. By convention, <tt class="xref docutils literal"><span class="pre">False</span></tt> and <tt class="xref docutils literal"><span class="pre">True</span></tt> are
returned for a successful comparison. However, these methods can
return any value, so if the comparison operator is used in a
Boolean context (e.g., in the condition of an <tt class="docutils literal"><span class="pre">if</span></tt> statement),
Python will call <tt class="docutils literal"><span class="pre">bool()</span></tt> on the value to determine if the result
is true or false.</p>
<p>There are no implied relationships among the comparison operators.
The truth of <tt class="docutils literal"><span class="pre">x==y</span></tt> does not imply that <tt class="docutils literal"><span class="pre">x!=y</span></tt> is false.
Accordingly, when defining <tt class="docutils literal"><span class="pre">__eq__()</span></tt>, one should also define
<tt class="docutils literal"><span class="pre">__ne__()</span></tt> so that the operators will behave as expected.  See
the paragraph on <tt class="docutils literal"><span class="pre">__hash__()</span></tt> for some important notes on
creating <em>hashable</em> objects which support custom comparison
operations and are usable as dictionary keys.</p>
<p>There are no swapped-argument versions of these methods (to be used
when the left argument does not support the operation but the right
argument does); rather, <tt class="docutils literal"><span class="pre">__lt__()</span></tt> and <tt class="docutils literal"><span class="pre">__gt__()</span></tt> are each
other&#8217;s reflection, <tt class="docutils literal"><span class="pre">__le__()</span></tt> and <tt class="docutils literal"><span class="pre">__ge__()</span></tt> are each other&#8217;s
reflection, and <tt class="docutils literal"><span class="pre">__eq__()</span></tt> and <tt class="docutils literal"><span class="pre">__ne__()</span></tt> are their own
reflection.</p>
<p>Arguments to rich comparison methods are never coerced.</p>
</blockquote>
<p>object.__cmp__(self, other)</p>
<blockquote>
Called by comparison operations if rich comparison (see above) is
not defined.  Should return a negative integer if <tt class="docutils literal"><span class="pre">self</span> <span class="pre">&lt;</span> <span class="pre">other</span></tt>,
zero if <tt class="docutils literal"><span class="pre">self</span> <span class="pre">==</span> <span class="pre">other</span></tt>, a positive integer if <tt class="docutils literal"><span class="pre">self</span> <span class="pre">&gt;</span> <span class="pre">other</span></tt>.
If no <tt class="docutils literal"><span class="pre">__cmp__()</span></tt>, <tt class="docutils literal"><span class="pre">__eq__()</span></tt> or <tt class="docutils literal"><span class="pre">__ne__()</span></tt> operation is
defined, class instances are compared by object identity
(&#8220;address&#8221;).  See also the description of <tt class="docutils literal"><span class="pre">__hash__()</span></tt> for some
important notes on creating <em>hashable</em> objects which support custom
comparison operations and are usable as dictionary keys. (Note: the
restriction that exceptions are not propagated by <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> has
been removed since Python 1.5.)</blockquote>
<p>object.__rcmp__(self, other)</p>
<blockquote>
Changed in version 2.1: No longer supported.</blockquote>
<p>object.__hash__(self)</p>
<blockquote>
<p>Called by built-in function <tt class="docutils literal"><span class="pre">hash()</span></tt> and for operations on
members of hashed collections including <tt class="docutils literal"><span class="pre">set</span></tt>, <tt class="docutils literal"><span class="pre">frozenset</span></tt>, and
<tt class="docutils literal"><span class="pre">dict</span></tt>.  <tt class="docutils literal"><span class="pre">__hash__()</span></tt> should return an integer.  The only
required property is that objects which compare equal have the same
hash value; it is advised to somehow mix together (e.g. using
exclusive or) the hash values for the components of the object that
also play a part in comparison of objects.</p>
<p>If a class does not define a <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> or <tt class="docutils literal"><span class="pre">__eq__()</span></tt> method
it should not define a <tt class="docutils literal"><span class="pre">__hash__()</span></tt> operation either; if it
defines <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> or <tt class="docutils literal"><span class="pre">__eq__()</span></tt> but not <tt class="docutils literal"><span class="pre">__hash__()</span></tt>, its
instances will not be usable in hashed collections.  If a class
defines mutable objects and implements a <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> or
<tt class="docutils literal"><span class="pre">__eq__()</span></tt> method, it should not implement <tt class="docutils literal"><span class="pre">__hash__()</span></tt>, since
hashable collection implementations require that a object&#8217;s hash
value is immutable (if the object&#8217;s hash value changes, it will be
in the wrong hash bucket).</p>
<p>User-defined classes have <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> and <tt class="docutils literal"><span class="pre">__hash__()</span></tt> methods
by default; with them, all objects compare unequal (except with
themselves) and <tt class="docutils literal"><span class="pre">x.__hash__()</span></tt> returns <tt class="docutils literal"><span class="pre">id(x)</span></tt>.</p>
<p>Classes which inherit a <tt class="docutils literal"><span class="pre">__hash__()</span></tt> method from a parent class
but change the meaning of <tt class="docutils literal"><span class="pre">__cmp__()</span></tt> or <tt class="docutils literal"><span class="pre">__eq__()</span></tt> such that
the hash value returned is no longer appropriate (e.g. by switching
to a value-based concept of equality instead of the default
identity based equality) can explicitly flag themselves as being
unhashable by setting <tt class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></tt> in the class definition.
Doing so means that not only will instances of the class raise an
appropriate <tt class="docutils literal"><span class="pre">TypeError</span></tt> when a program attempts to retrieve their
hash value, but they will also be correctly identified as
unhashable when checking <tt class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></tt>
(unlike classes which define their own <tt class="docutils literal"><span class="pre">__hash__()</span></tt> to explicitly
raise <tt class="docutils literal"><span class="pre">TypeError</span></tt>).</p>
<p>Changed in version 2.5: <tt class="docutils literal"><span class="pre">__hash__()</span></tt> may now also return a long
integer object; the 32-bit integer is then derived from the hash of
that object.</p>
<p>Changed in version 2.6: <tt class="docutils literal"><span class="pre">__hash__</span></tt> may now be set to <tt class="xref docutils literal"><span class="pre">None</span></tt> to
explicitly flag instances of a class as unhashable.</p>
</blockquote>
<p>object.__nonzero__(self)</p>
<blockquote>
Called to implement truth value testing and the built-in operation
<tt class="docutils literal"><span class="pre">bool()</span></tt>; should return <tt class="xref docutils literal"><span class="pre">False</span></tt> or <tt class="xref docutils literal"><span class="pre">True</span></tt>, or their integer
equivalents <tt class="docutils literal"><span class="pre">0</span></tt> or <tt class="docutils literal"><span class="pre">1</span></tt>.  When this method is not defined,
<tt class="docutils literal"><span class="pre">__len__()</span></tt> is called, if it is defined, and the object is
considered true if its result is nonzero. If a class defines
neither <tt class="docutils literal"><span class="pre">__len__()</span></tt> nor <tt class="docutils literal"><span class="pre">__nonzero__()</span></tt>, all its instances are
considered true.</blockquote>
<p>object.__unicode__(self)</p>
<blockquote>
Called to implement <tt class="docutils literal"><span class="pre">unicode()</span></tt> builtin; should return a Unicode
object. When this method is not defined, string conversion is
attempted, and the result of string conversion is converted to
Unicode using the system default encoding.</blockquote>
</div>
<div class="section" id="customizing-attribute-access">
<h3>3.4.2. Customizing attribute access<a class="headerlink" href="#customizing-attribute-access" title="Permalink to this headline">¶</a></h3>
<p>The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of <tt class="docutils literal"><span class="pre">x.name</span></tt>)
for class instances.</p>
<p>object.__getattr__(self, name)</p>
<blockquote>
<p>Called when an attribute lookup has not found the attribute in the
usual places (i.e. it is not an instance attribute nor is it found
in the class tree for <tt class="docutils literal"><span class="pre">self</span></tt>).  <tt class="docutils literal"><span class="pre">name</span></tt> is the attribute name.
This method should return the (computed) attribute value or raise
an <tt class="docutils literal"><span class="pre">AttributeError</span></tt> exception.</p>
<p>Note that if the attribute is found through the normal mechanism,
<tt class="docutils literal"><span class="pre">__getattr__()</span></tt> is not called.  (This is an intentional asymmetry
between <tt class="docutils literal"><span class="pre">__getattr__()</span></tt> and <tt class="docutils literal"><span class="pre">__setattr__()</span></tt>.) This is done both
for efficiency reasons and because otherwise <tt class="docutils literal"><span class="pre">__getattr__()</span></tt>
would have no way to access other attributes of the instance.  Note
that at least for instance variables, you can fake total control by
not inserting any values in the instance attribute dictionary (but
instead inserting them in another object).  See the
<tt class="docutils literal"><span class="pre">__getattribute__()</span></tt> method below for a way to actually get total
control in new-style classes.</p>
</blockquote>
<p>object.__setattr__(self, name, value)</p>
<blockquote>
<p>Called when an attribute assignment is attempted.  This is called
instead of the normal mechanism (i.e. store the value in the
instance dictionary).  <em>name</em> is the attribute name, <em>value</em> is the
value to be assigned to it.</p>
<p>If <tt class="docutils literal"><span class="pre">__setattr__()</span></tt> wants to assign to an instance attribute, it
should not simply execute <tt class="docutils literal"><span class="pre">self.name</span> <span class="pre">=</span> <span class="pre">value</span></tt> &#8212; this would
cause a recursive call to itself.  Instead, it should insert the
value in the dictionary of instance attributes, e.g.,
<tt class="docutils literal"><span class="pre">self.__dict__[name]</span> <span class="pre">=</span> <span class="pre">value</span></tt>.  For new-style classes, rather
than accessing the instance dictionary, it should call the base
class method with the same name, for example,
<tt class="docutils literal"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></tt>.</p>
</blockquote>
<p>object.__delattr__(self, name)</p>
<blockquote>
Like <tt class="docutils literal"><span class="pre">__setattr__()</span></tt> but for attribute deletion instead of
assignment.  This should only be implemented if <tt class="docutils literal"><span class="pre">del</span> <span class="pre">obj.name</span></tt> is
meaningful for the object.</blockquote>
<div class="section" id="more-attribute-access-for-new-style-classes">
<h4>3.4.2.1. More attribute access for new-style classes<a class="headerlink" href="#more-attribute-access-for-new-style-classes" title="Permalink to this headline">¶</a></h4>
<p>The following methods only apply to new-style classes.</p>
<p>object.__getattribute__(self, name)</p>
<blockquote>
<p>Called unconditionally to implement attribute accesses for
instances of the class. If the class also defines
<tt class="docutils literal"><span class="pre">__getattr__()</span></tt>, the latter will not be called unless
<tt class="docutils literal"><span class="pre">__getattribute__()</span></tt> either calls it explicitly or raises an
<tt class="docutils literal"><span class="pre">AttributeError</span></tt>. This method should return the (computed)
attribute value or raise an <tt class="docutils literal"><span class="pre">AttributeError</span></tt> exception. In order
to avoid infinite recursion in this method, its implementation
should always call the base class method with the same name to
access any attributes it needs, for example,
<tt class="docutils literal"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></tt>.</p>
<dl class="docutils">
<dt>Note: This method may still be bypassed when looking up special methods</dt>
<dd>as the result of implicit invocation via language syntax or
builtin functions. See <em>Special method lookup for new-style
classes</em>.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="implementing-descriptors">
<h4>3.4.2.2. Implementing Descriptors<a class="headerlink" href="#implementing-descriptors" title="Permalink to this headline">¶</a></h4>
<p>The following methods only apply when an instance of the class
containing the method (a so-called <em>descriptor</em> class) appears in the
class dictionary of another new-style class, known as the <em>owner</em>
class. In the examples below, &#8220;the attribute&#8221; refers to the attribute
whose name is the key of the property in the owner class&#8217;
<tt class="docutils literal"><span class="pre">__dict__</span></tt>.  Descriptors can only be implemented as new-style
classes themselves.</p>
<p>object.__get__(self, instance, owner)</p>
<blockquote>
Called to get the attribute of the owner class (class attribute
access) or of an instance of that class (instance attribute
access). <em>owner</em> is always the owner class, while <em>instance</em> is the
instance that the attribute was accessed through, or <tt class="xref docutils literal"><span class="pre">None</span></tt> when
the attribute is accessed through the <em>owner</em>.  This method should
return the (computed) attribute value or raise an
<tt class="docutils literal"><span class="pre">AttributeError</span></tt> exception.</blockquote>
<p>object.__set__(self, instance, value)</p>
<blockquote>
Called to set the attribute on an instance <em>instance</em> of the owner
class to a new value, <em>value</em>.</blockquote>
<p>object.__delete__(self, instance)</p>
<blockquote>
Called to delete the attribute on an instance <em>instance</em> of the
owner class.</blockquote>
</div>
<div class="section" id="invoking-descriptors">
<h4>3.4.2.3. Invoking Descriptors<a class="headerlink" href="#invoking-descriptors" title="Permalink to this headline">¶</a></h4>
<p>In general, a descriptor is an object attribute with &#8220;binding
behavior&#8221;, one whose attribute access has been overridden by methods
in the descriptor protocol:  <tt class="docutils literal"><span class="pre">__get__()</span></tt>, <tt class="docutils literal"><span class="pre">__set__()</span></tt>, and
<tt class="docutils literal"><span class="pre">__delete__()</span></tt>. If any of those methods are defined for an object,
it is said to be a descriptor.</p>
<p>The default behavior for attribute access is to get, set, or delete
the attribute from an object&#8217;s dictionary. For instance, <tt class="docutils literal"><span class="pre">a.x</span></tt> has a
lookup chain starting with <tt class="docutils literal"><span class="pre">a.__dict__['x']</span></tt>, then
<tt class="docutils literal"><span class="pre">type(a).__dict__['x']</span></tt>, and continuing through the base classes of
<tt class="docutils literal"><span class="pre">type(a)</span></tt> excluding metaclasses.</p>
<p>However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.  Note that descriptors are only invoked for new
style objects or classes (ones that subclass <tt class="docutils literal"><span class="pre">object()</span></tt> or
<tt class="docutils literal"><span class="pre">type()</span></tt>).</p>
<p>The starting point for descriptor invocation is a binding, <tt class="docutils literal"><span class="pre">a.x</span></tt>.
How the arguments are assembled depends on <tt class="docutils literal"><span class="pre">a</span></tt>:</p>
<dl class="docutils">
<dt>Direct Call</dt>
<dd>The simplest and least common call is when user code directly
invokes a descriptor method:    <tt class="docutils literal"><span class="pre">x.__get__(a)</span></tt>.</dd>
<dt>Instance Binding</dt>
<dd>If binding to a new-style object instance, <tt class="docutils literal"><span class="pre">a.x</span></tt> is transformed
into the call: <tt class="docutils literal"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></tt>.</dd>
<dt>Class Binding</dt>
<dd>If binding to a new-style class, <tt class="docutils literal"><span class="pre">A.x</span></tt> is transformed into the
call: <tt class="docutils literal"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></tt>.</dd>
<dt>Super Binding</dt>
<dd>If <tt class="docutils literal"><span class="pre">a</span></tt> is an instance of <tt class="docutils literal"><span class="pre">super</span></tt>, then the binding <tt class="docutils literal"><span class="pre">super(B,</span>
<span class="pre">obj).m()</span></tt> searches <tt class="docutils literal"><span class="pre">obj.__class__.__mro__</span></tt> for the base class
<tt class="docutils literal"><span class="pre">A</span></tt> immediately preceding <tt class="docutils literal"><span class="pre">B</span></tt> and then invokes the descriptor
with the call: <tt class="docutils literal"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">A)</span></tt>.</dd>
</dl>
<p>For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  Normally, data
descriptors define both <tt class="docutils literal"><span class="pre">__get__()</span></tt> and <tt class="docutils literal"><span class="pre">__set__()</span></tt>, while non-
data descriptors have just the <tt class="docutils literal"><span class="pre">__get__()</span></tt> method.  Data descriptors
always override a redefinition in an instance dictionary.  In
contrast, non-data descriptors can be overridden by instances. [2]</p>
<p>Python methods (including <tt class="docutils literal"><span class="pre">staticmethod()</span></tt> and <tt class="docutils literal"><span class="pre">classmethod()</span></tt>)
are implemented as non-data descriptors.  Accordingly, instances can
redefine and override methods.  This allows individual instances to
acquire behaviors that differ from other instances of the same class.</p>
<p>The <tt class="docutils literal"><span class="pre">property()</span></tt> function is implemented as a data descriptor.
Accordingly, instances cannot override the behavior of a property.</p>
</div>
<div class="section" id="slots">
<h4>3.4.2.4. __slots__<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h4>
<p>By default, instances of both old and new-style classes have a
dictionary for attribute storage.  This wastes space for objects
having very few instance variables.  The space consumption can become
acute when creating large numbers of instances.</p>
<p>The default can be overridden by defining <em>__slots__</em> in a new-style
class definition.  The <em>__slots__</em> declaration takes a sequence of
instance variables and reserves just enough space in each instance to
hold a value for each variable.  Space is saved because <em>__dict__</em> is
not created for each instance.</p>
<p>__slots__</p>
<blockquote>
<p>This class variable can be assigned a string, iterable, or sequence
of strings with variable names used by instances.  If defined in a
new-style class, <em>__slots__</em> reserves space for the declared
variables and prevents the automatic creation of <em>__dict__</em> and
<em>__weakref__</em> for each instance.</p>
<p>New in version 2.2.</p>
</blockquote>
<p>Notes on using <em>__slots__</em></p>
<ul>
<li><p class="first">When inheriting from a class without <em>__slots__</em>, the <em>__dict__</em>
attribute of that class will always be accessible, so a <em>__slots__</em>
definition in the subclass is meaningless.</p>
</li>
<li><p class="first">Without a <em>__dict__</em> variable, instances cannot be assigned new
variables not listed in the <em>__slots__</em> definition.  Attempts to
assign to an unlisted variable name raises <tt class="docutils literal"><span class="pre">AttributeError</span></tt>. If
dynamic assignment of new variables is desired, then add
<tt class="docutils literal"><span class="pre">'__dict__'</span></tt> to the sequence of strings in the <em>__slots__</em>
declaration.</p>
<p>Changed in version 2.3: Previously, adding <tt class="docutils literal"><span class="pre">'__dict__'</span></tt> to the
<em>__slots__</em> declaration would not enable the assignment of new
attributes not specifically listed in the sequence of instance
variable names.</p>
</li>
<li><p class="first">Without a <em>__weakref__</em> variable for each instance, classes defining
<em>__slots__</em> do not support weak references to its instances. If weak
reference support is needed, then add <tt class="docutils literal"><span class="pre">'__weakref__'</span></tt> to the
sequence of strings in the <em>__slots__</em> declaration.</p>
<p>Changed in version 2.3: Previously, adding <tt class="docutils literal"><span class="pre">'__weakref__'</span></tt> to the
<em>__slots__</em> declaration would not enable support for weak
references.</p>
</li>
<li><p class="first"><em>__slots__</em> are implemented at the class level by creating
descriptors (<em>Implementing Descriptors</em>) for each variable name.  As
a result, class attributes cannot be used to set default values for
instance variables defined by <em>__slots__</em>; otherwise, the class
attribute would overwrite the descriptor assignment.</p>
</li>
<li><p class="first">If a class defines a slot also defined in a base class, the instance
variable defined by the base class slot is inaccessible (except by
retrieving its descriptor directly from the base class). This
renders the meaning of the program undefined.  In the future, a
check may be added to prevent this.</p>
</li>
<li><p class="first">The action of a <em>__slots__</em> declaration is limited to the class
where it is defined.  As a result, subclasses will have a <em>__dict__</em>
unless they also define <em>__slots__</em>.</p>
</li>
<li><p class="first">Nonempty <em>__slots__</em> does not work for classes derived from
&#8220;variable-length&#8221; built-in types such as <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">str</span></tt> and
<tt class="docutils literal"><span class="pre">tuple</span></tt>.</p>
</li>
<li><p class="first">Any non-string iterable may be assigned to <em>__slots__</em>. Mappings may
also be used; however, in the future, special meaning may be
assigned to the values corresponding to each key.</p>
</li>
<li><p class="first"><em>__class__</em> assignment works only if both classes have the same
<em>__slots__</em>.</p>
<p>Changed in version 2.6: Previously, <em>__class__</em> assignment raised an
error if either new or old class had <em>__slots__</em>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="customizing-class-creation">
<h3>3.4.3. Customizing class creation<a class="headerlink" href="#customizing-class-creation" title="Permalink to this headline">¶</a></h3>
<p>By default, new-style classes are constructed using <tt class="docutils literal"><span class="pre">type()</span></tt>. A
class definition is read into a separate namespace and the value of
class name is bound to the result of <tt class="docutils literal"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">dict)</span></tt>.</p>
<p>When the class definition is read, if <em>__metaclass__</em> is defined then
the callable assigned to it will be called instead of <tt class="docutils literal"><span class="pre">type()</span></tt>. This
allows classes or functions to be written which monitor or alter the
class creation process:</p>
<ul class="simple">
<li>Modifying the class dictionary prior to the class being created.</li>
<li>Returning an instance of another class &#8211; essentially performing the
role of a factory function.</li>
</ul>
<p>These steps will have to be performed in the metaclass&#8217;s <tt class="docutils literal"><span class="pre">__new__()</span></tt>
method &#8211; <tt class="docutils literal"><span class="pre">type.__new__()</span></tt> can then be called from this method to
create a class with different properties.  This example adds a new
element to the class dictionary before creating the class:</p>
<blockquote>
<dl class="docutils">
<dt>class metacls(type):</dt>
<dd><dl class="first last docutils">
<dt>def __new__(mcs, name, bases, dict):</dt>
<dd>dict[&#8216;foo&#8217;] = &#8216;metacls was here&#8217;
return type.__new__(mcs, name, bases, dict)</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>You can of course also override other class methods (or add new
methods); for example defining a custom <tt class="docutils literal"><span class="pre">__call__()</span></tt> method in the
metaclass allows custom behavior when the class is called, e.g. not
always creating a new instance.</p>
<p>__metaclass__</p>
<blockquote>
<p>This variable can be any callable accepting arguments for <tt class="docutils literal"><span class="pre">name</span></tt>,
<tt class="docutils literal"><span class="pre">bases</span></tt>, and <tt class="docutils literal"><span class="pre">dict</span></tt>.  Upon class creation, the callable is used
instead of the built-in <tt class="docutils literal"><span class="pre">type()</span></tt>.</p>
<p>New in version 2.2.</p>
</blockquote>
<p>The appropriate metaclass is determined by the following precedence
rules:</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">dict['__metaclass__']</span></tt> exists, it is used.</li>
<li>Otherwise, if there is at least one base class, its metaclass is
used (this looks for a <em>__class__</em> attribute first and if not found,
uses its type).</li>
<li>Otherwise, if a global variable named __metaclass__ exists, it is
used.</li>
<li>Otherwise, the old-style, classic metaclass (types.ClassType) is
used.</li>
</ul>
<p>The potential uses for metaclasses are boundless. Some ideas that have
been explored including logging, interface checking, automatic
delegation, automatic property creation, proxies, frameworks, and
automatic resource locking/synchronization.</p>
</div>
<div class="section" id="emulating-callable-objects">
<h3>3.4.4. Emulating callable objects<a class="headerlink" href="#emulating-callable-objects" title="Permalink to this headline">¶</a></h3>
<p>object.__call__(self[, args...])</p>
<blockquote>
Called when the instance is &#8220;called&#8221; as a function; if this method
is defined, <tt class="docutils literal"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></tt> is a shorthand for
<tt class="docutils literal"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></tt>.</blockquote>
</div>
<div class="section" id="emulating-container-types">
<h3>3.4.5. Emulating container types<a class="headerlink" href="#emulating-container-types" title="Permalink to this headline">¶</a></h3>
<p>The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to
emulate a mapping; the difference is that for a sequence, the
allowable keys should be the integers <em>k</em> for which <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></tt>
where <em>N</em> is the length of the sequence, or slice objects, which
define a range of items. (For backwards compatibility, the method
<tt class="docutils literal"><span class="pre">__getslice__()</span></tt> (see below) can also be defined to handle simple,
but not extended slices.) It is also recommended that mappings provide
the methods <tt class="docutils literal"><span class="pre">keys()</span></tt>, <tt class="docutils literal"><span class="pre">values()</span></tt>, <tt class="docutils literal"><span class="pre">items()</span></tt>, <tt class="docutils literal"><span class="pre">has_key()</span></tt>,
<tt class="docutils literal"><span class="pre">get()</span></tt>, <tt class="docutils literal"><span class="pre">clear()</span></tt>, <tt class="docutils literal"><span class="pre">setdefault()</span></tt>, <tt class="docutils literal"><span class="pre">iterkeys()</span></tt>,
<tt class="docutils literal"><span class="pre">itervalues()</span></tt>, <tt class="docutils literal"><span class="pre">iteritems()</span></tt>, <tt class="docutils literal"><span class="pre">pop()</span></tt>, <tt class="docutils literal"><span class="pre">popitem()</span></tt>,
<tt class="docutils literal"><span class="pre">copy()</span></tt>, and <tt class="docutils literal"><span class="pre">update()</span></tt> behaving similar to those for Python&#8217;s
standard dictionary objects.  The <tt class="docutils literal"><span class="pre">UserDict</span></tt> module provides a
<tt class="docutils literal"><span class="pre">DictMixin</span></tt> class to help create those methods from a base set of
<tt class="docutils literal"><span class="pre">__getitem__()</span></tt>, <tt class="docutils literal"><span class="pre">__setitem__()</span></tt>, <tt class="docutils literal"><span class="pre">__delitem__()</span></tt>, and
<tt class="docutils literal"><span class="pre">keys()</span></tt>. Mutable sequences should provide methods <tt class="docutils literal"><span class="pre">append()</span></tt>,
<tt class="docutils literal"><span class="pre">count()</span></tt>, <tt class="docutils literal"><span class="pre">index()</span></tt>, <tt class="docutils literal"><span class="pre">extend()</span></tt>, <tt class="docutils literal"><span class="pre">insert()</span></tt>, <tt class="docutils literal"><span class="pre">pop()</span></tt>,
<tt class="docutils literal"><span class="pre">remove()</span></tt>, <tt class="docutils literal"><span class="pre">reverse()</span></tt> and <tt class="docutils literal"><span class="pre">sort()</span></tt>, like Python standard list
objects.  Finally, sequence types should implement addition (meaning
concatenation) and multiplication (meaning repetition) by defining the
methods <tt class="docutils literal"><span class="pre">__add__()</span></tt>, <tt class="docutils literal"><span class="pre">__radd__()</span></tt>, <tt class="docutils literal"><span class="pre">__iadd__()</span></tt>, <tt class="docutils literal"><span class="pre">__mul__()</span></tt>,
<tt class="docutils literal"><span class="pre">__rmul__()</span></tt> and <tt class="docutils literal"><span class="pre">__imul__()</span></tt> described below; they should not
define <tt class="docutils literal"><span class="pre">__coerce__()</span></tt> or other numerical operators.  It is
recommended that both mappings and sequences implement the
<tt class="docutils literal"><span class="pre">__contains__()</span></tt> method to allow efficient use of the <tt class="docutils literal"><span class="pre">in</span></tt>
operator; for mappings, <tt class="docutils literal"><span class="pre">in</span></tt> should be equivalent of <tt class="docutils literal"><span class="pre">has_key()</span></tt>;
for sequences, it should search through the values.  It is further
recommended that both mappings and sequences implement the
<tt class="docutils literal"><span class="pre">__iter__()</span></tt> method to allow efficient iteration through the
container; for mappings, <tt class="docutils literal"><span class="pre">__iter__()</span></tt> should be the same as
<tt class="docutils literal"><span class="pre">iterkeys()</span></tt>; for sequences, it should iterate through the values.</p>
<p>object.__len__(self)</p>
<blockquote>
Called to implement the built-in function <tt class="docutils literal"><span class="pre">len()</span></tt>.  Should return
the length of the object, an integer <tt class="docutils literal"><span class="pre">&gt;=</span></tt> 0.  Also, an object
that doesn&#8217;t define a <tt class="docutils literal"><span class="pre">__nonzero__()</span></tt> method and whose
<tt class="docutils literal"><span class="pre">__len__()</span></tt> method returns zero is considered to be false in a
Boolean context.</blockquote>
<p>object.__getitem__(self, key)</p>
<blockquote>
<p>Called to implement evaluation of <tt class="docutils literal"><span class="pre">self[key]</span></tt>. For sequence
types, the accepted keys should be integers and slice objects.
Note that the special interpretation of negative indexes (if the
class wishes to emulate a sequence type) is up to the
<tt class="docutils literal"><span class="pre">__getitem__()</span></tt> method. If <em>key</em> is of an inappropriate type,
<tt class="docutils literal"><span class="pre">TypeError</span></tt> may be raised; if of a value outside the set of
indexes for the sequence (after any special interpretation of
negative values), <tt class="docutils literal"><span class="pre">IndexError</span></tt> should be raised. For mapping
types, if <em>key</em> is missing (not in the container), <tt class="docutils literal"><span class="pre">KeyError</span></tt>
should be raised.</p>
<dl class="docutils">
<dt>Note: <tt class="docutils literal"><span class="pre">for</span></tt> loops expect that an <tt class="docutils literal"><span class="pre">IndexError</span></tt> will be raised for</dt>
<dd>illegal indexes to allow proper detection of the end of the
sequence.</dd>
</dl>
</blockquote>
<p>object.__setitem__(self, key, value)</p>
<blockquote>
Called to implement assignment to <tt class="docutils literal"><span class="pre">self[key]</span></tt>.  Same note as for
<tt class="docutils literal"><span class="pre">__getitem__()</span></tt>.  This should only be implemented for mappings if
the objects support changes to the values for keys, or if new keys
can be added, or for sequences if elements can be replaced.  The
same exceptions should be raised for improper <em>key</em> values as for
the <tt class="docutils literal"><span class="pre">__getitem__()</span></tt> method.</blockquote>
<p>object.__delitem__(self, key)</p>
<blockquote>
Called to implement deletion of <tt class="docutils literal"><span class="pre">self[key]</span></tt>.  Same note as for
<tt class="docutils literal"><span class="pre">__getitem__()</span></tt>.  This should only be implemented for mappings if
the objects support removal of keys, or for sequences if elements
can be removed from the sequence.  The same exceptions should be
raised for improper <em>key</em> values as for the <tt class="docutils literal"><span class="pre">__getitem__()</span></tt>
method.</blockquote>
<p>object.__iter__(self)</p>
<blockquote>
<p>This method is called when an iterator is required for a container.
This method should return a new iterator object that can iterate
over all the objects in the container.  For mappings, it should
iterate over the keys of the container, and should also be made
available as the method <tt class="docutils literal"><span class="pre">iterkeys()</span></tt>.</p>
<p>Iterator objects also need to implement this method; they are
required to return themselves.  For more information on iterator
objects, see <em>Iterator Types</em>.</p>
</blockquote>
<p>object.__reversed__(self)</p>
<blockquote>
<p>Called (if present) by the <tt class="docutils literal"><span class="pre">reversed()</span></tt> builtin to implement
reverse iteration.  It should return a new iterator object that
iterates over all the objects in the container in reverse order.</p>
<p>If the <tt class="docutils literal"><span class="pre">__reversed__()</span></tt> method is not provided, the
<tt class="docutils literal"><span class="pre">reversed()</span></tt> builtin will fall back to using the sequence
protocol (<tt class="docutils literal"><span class="pre">__len__()</span></tt> and <tt class="docutils literal"><span class="pre">__getitem__()</span></tt>).  Objects that
support the sequence protocol should only provide
<tt class="docutils literal"><span class="pre">__reversed__()</span></tt> if they can provide an implementation that is
more efficient than the one provided by <tt class="docutils literal"><span class="pre">reversed()</span></tt>.</p>
<p>New in version 2.6.</p>
</blockquote>
<p>The membership test operators (<tt class="docutils literal"><span class="pre">in</span></tt> and <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt>) are normally
implemented as an iteration through a sequence.  However, container
objects can supply the following special method with a more efficient
implementation, which also does not require the object be a sequence.</p>
<p>object.__contains__(self, item)</p>
<blockquote>
Called to implement membership test operators.  Should return true
if <em>item</em> is in <em>self</em>, false otherwise.  For mapping objects, this
should consider the keys of the mapping rather than the values or
the key-item pairs.</blockquote>
</div>
<div class="section" id="additional-methods-for-emulation-of-sequence-types">
<h3>3.4.6. Additional methods for emulation of sequence types<a class="headerlink" href="#additional-methods-for-emulation-of-sequence-types" title="Permalink to this headline">¶</a></h3>
<p>The following optional methods can be defined to further emulate
sequence objects.  Immutable sequences methods should at most only
define <tt class="docutils literal"><span class="pre">__getslice__()</span></tt>; mutable sequences might define all three
methods.</p>
<p>object.__getslice__(self, i, j)</p>
<blockquote>
<p>Deprecated since version 2.0: Support slice objects as parameters
to the <tt class="docutils literal"><span class="pre">__getitem__()</span></tt> method. (However, built-in types in
CPython currently still implement <tt class="docutils literal"><span class="pre">__getslice__()</span></tt>.  Therefore,
you have to override it in derived classes when implementing
slicing.)</p>
<p>Called to implement evaluation of <tt class="docutils literal"><span class="pre">self[i:j]</span></tt>. The returned
object should be of the same type as <em>self</em>.  Note that missing <em>i</em>
or <em>j</em> in the slice expression are replaced by zero or
<tt class="docutils literal"><span class="pre">sys.maxint</span></tt>, respectively.  If negative indexes are used in the
slice, the length of the sequence is added to that index. If the
instance does not implement the <tt class="docutils literal"><span class="pre">__len__()</span></tt> method, an
<tt class="docutils literal"><span class="pre">AttributeError</span></tt> is raised. No guarantee is made that indexes
adjusted this way are not still negative.  Indexes which are
greater than the length of the sequence are not modified. If no
<tt class="docutils literal"><span class="pre">__getslice__()</span></tt> is found, a slice object is created instead, and
passed to <tt class="docutils literal"><span class="pre">__getitem__()</span></tt> instead.</p>
</blockquote>
<p>object.__setslice__(self, i, j, sequence)</p>
<blockquote>
<p>Called to implement assignment to <tt class="docutils literal"><span class="pre">self[i:j]</span></tt>. Same notes for <em>i</em>
and <em>j</em> as for <tt class="docutils literal"><span class="pre">__getslice__()</span></tt>.</p>
<p>This method is deprecated. If no <tt class="docutils literal"><span class="pre">__setslice__()</span></tt> is found, or
for extended slicing of the form <tt class="docutils literal"><span class="pre">self[i:j:k]</span></tt>, a slice object is
created, and passed to <tt class="docutils literal"><span class="pre">__setitem__()</span></tt>, instead of
<tt class="docutils literal"><span class="pre">__setslice__()</span></tt> being called.</p>
</blockquote>
<p>object.__delslice__(self, i, j)</p>
<blockquote>
Called to implement deletion of <tt class="docutils literal"><span class="pre">self[i:j]</span></tt>. Same notes for <em>i</em>
and <em>j</em> as for <tt class="docutils literal"><span class="pre">__getslice__()</span></tt>. This method is deprecated. If no
<tt class="docutils literal"><span class="pre">__delslice__()</span></tt> is found, or for extended slicing of the form
<tt class="docutils literal"><span class="pre">self[i:j:k]</span></tt>, a slice object is created, and passed to
<tt class="docutils literal"><span class="pre">__delitem__()</span></tt>, instead of <tt class="docutils literal"><span class="pre">__delslice__()</span></tt> being called.</blockquote>
<p>Notice that these methods are only invoked when a single slice with a
single colon is used, and the slice method is available.  For slice
operations involving extended slice notation, or in absence of the
slice methods, <tt class="docutils literal"><span class="pre">__getitem__()</span></tt>, <tt class="docutils literal"><span class="pre">__setitem__()</span></tt> or
<tt class="docutils literal"><span class="pre">__delitem__()</span></tt> is called with a slice object as argument.</p>
<p>The following example demonstrate how to make your program or module
compatible with earlier versions of Python (assuming that methods
<tt class="docutils literal"><span class="pre">__getitem__()</span></tt>, <tt class="docutils literal"><span class="pre">__setitem__()</span></tt> and <tt class="docutils literal"><span class="pre">__delitem__()</span></tt> support
slice objects as arguments):</p>
<blockquote>
<dl class="docutils">
<dt>class MyClass:</dt>
<dd><p class="first">...
def __getitem__(self, index):</p>
<blockquote>
...</blockquote>
<dl class="docutils">
<dt>def __setitem__(self, index, value):</dt>
<dd>...</dd>
<dt>def __delitem__(self, index):</dt>
<dd>...</dd>
<dt>if sys.version_info &lt; (2, 0):</dt>
<dd><p class="first"># They won&#8217;t be defined if version is at least 2.0 final</p>
<dl class="last docutils">
<dt>def __getslice__(self, i, j):</dt>
<dd>return self[max(0, i):max(0, j):]</dd>
<dt>def __setslice__(self, i, j, seq):</dt>
<dd>self[max(0, i):max(0, j):] = seq</dd>
<dt>def __delslice__(self, i, j):</dt>
<dd>del self[max(0, i):max(0, j):]</dd>
</dl>
</dd>
</dl>
<p class="last">...</p>
</dd>
</dl>
</blockquote>
<p>Note the calls to <tt class="docutils literal"><span class="pre">max()</span></tt>; these are necessary because of the
handling of negative indices before the <tt class="docutils literal"><span class="pre">__*slice__()</span></tt> methods are
called.  When negative indexes are used, the <tt class="docutils literal"><span class="pre">__*item__()</span></tt> methods
receive them as provided, but the <tt class="docutils literal"><span class="pre">__*slice__()</span></tt> methods get a
&#8220;cooked&#8221; form of the index values.  For each negative index value, the
length of the sequence is added to the index before calling the method
(which may still result in a negative index); this is the customary
handling of negative indexes by the built-in sequence types, and the
<tt class="docutils literal"><span class="pre">__*item__()</span></tt> methods are expected to do this as well.  However,
since they should already be doing that, negative indexes cannot be
passed in; they must be constrained to the bounds of the sequence
before being passed to the <tt class="docutils literal"><span class="pre">__*item__()</span></tt> methods. Calling <tt class="docutils literal"><span class="pre">max(0,</span>
<span class="pre">i)</span></tt> conveniently returns the proper value.</p>
</div>
<div class="section" id="emulating-numeric-types">
<h3>3.4.7. Emulating numeric types<a class="headerlink" href="#emulating-numeric-types" title="Permalink to this headline">¶</a></h3>
<p>The following methods can be defined to emulate numeric objects.
Methods corresponding to operations that are not supported by the
particular kind of number implemented (e.g., bitwise operations for
non-integral numbers) should be left undefined.</p>
<p>object.__add__(self, other)
object.__sub__(self, other)
object.__mul__(self, other)
object.__floordiv__(self, other)
object.__mod__(self, other)
object.__divmod__(self, other)
object.__pow__(self, other[, modulo])
object.__lshift__(self, other)
object.__rshift__(self, other)
object.__and__(self, other)
object.__xor__(self, other)
object.__or__(self, other)</p>
<blockquote>
<p>These methods are called to implement the binary arithmetic
operations (<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">//</span></tt>, <tt class="docutils literal"><span class="pre">%</span></tt>, <tt class="docutils literal"><span class="pre">divmod()</span></tt>,
<tt class="docutils literal"><span class="pre">pow()</span></tt>, <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt>, <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>).  For
instance, to evaluate the expression <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt>, where <em>x</em> is an
instance of a class that has an <tt class="docutils literal"><span class="pre">__add__()</span></tt> method,
<tt class="docutils literal"><span class="pre">x.__add__(y)</span></tt> is called.  The <tt class="docutils literal"><span class="pre">__divmod__()</span></tt> method should be
the equivalent to using <tt class="docutils literal"><span class="pre">__floordiv__()</span></tt> and <tt class="docutils literal"><span class="pre">__mod__()</span></tt>; it
should not be related to <tt class="docutils literal"><span class="pre">__truediv__()</span></tt> (described below).  Note
that <tt class="docutils literal"><span class="pre">__pow__()</span></tt> should be defined to accept an optional third
argument if the ternary version of the built-in <tt class="docutils literal"><span class="pre">pow()</span></tt> function
is to be supported.</p>
<p>If one of those methods does not support the operation with the
supplied arguments, it should return <tt class="docutils literal"><span class="pre">NotImplemented</span></tt>.</p>
</blockquote>
<p>object.__div__(self, other)
object.__truediv__(self, other)</p>
<blockquote>
The division operator (<tt class="docutils literal"><span class="pre">/</span></tt>) is implemented by these methods.  The
<tt class="docutils literal"><span class="pre">__truediv__()</span></tt> method is used when <tt class="docutils literal"><span class="pre">__future__.division</span></tt> is in
effect, otherwise <tt class="docutils literal"><span class="pre">__div__()</span></tt> is used.  If only one of these two
methods is defined, the object will not support division in the
alternate context; <tt class="docutils literal"><span class="pre">TypeError</span></tt> will be raised instead.</blockquote>
<p>object.__radd__(self, other)
object.__rsub__(self, other)
object.__rmul__(self, other)
object.__rdiv__(self, other)
object.__rtruediv__(self, other)
object.__rfloordiv__(self, other)
object.__rmod__(self, other)
object.__rdivmod__(self, other)
object.__rpow__(self, other)
object.__rlshift__(self, other)
object.__rrshift__(self, other)
object.__rand__(self, other)
object.__rxor__(self, other)
object.__ror__(self, other)</p>
<blockquote>
<p>These methods are called to implement the binary arithmetic
operations (<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">%</span></tt>, <tt class="docutils literal"><span class="pre">divmod()</span></tt>,
<tt class="docutils literal"><span class="pre">pow()</span></tt>, <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt>, <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>) with
reflected (swapped) operands.  These functions are only called if
the left operand does not support the corresponding operation and
the operands are of different types. [3] For instance, to evaluate
the expression <tt class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></tt>, where <em>y</em> is an instance of a class that
has an <tt class="docutils literal"><span class="pre">__rsub__()</span></tt> method, <tt class="docutils literal"><span class="pre">y.__rsub__(x)</span></tt> is called if
<tt class="docutils literal"><span class="pre">x.__sub__(y)</span></tt> returns <em>NotImplemented</em>.</p>
<p>Note that ternary <tt class="docutils literal"><span class="pre">pow()</span></tt> will not try calling <tt class="docutils literal"><span class="pre">__rpow__()</span></tt>
(the coercion rules would become too complicated).</p>
<dl class="docutils">
<dt>Note: If the right operand&#8217;s type is a subclass of the left operand&#8217;s</dt>
<dd>type and that subclass provides the reflected method for the
operation, this method will be called before the left operand&#8217;s
non-reflected method.  This behavior allows subclasses to
override their ancestors&#8217; operations.</dd>
</dl>
</blockquote>
<p>object.__iadd__(self, other)
object.__isub__(self, other)
object.__imul__(self, other)
object.__idiv__(self, other)
object.__itruediv__(self, other)
object.__ifloordiv__(self, other)
object.__imod__(self, other)
object.__ipow__(self, other[, modulo])
object.__ilshift__(self, other)
object.__irshift__(self, other)
object.__iand__(self, other)
object.__ixor__(self, other)
object.__ior__(self, other)</p>
<blockquote>
These methods are called to implement the augmented arithmetic
assignments (<tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>, <tt class="docutils literal"><span class="pre">/=</span></tt>, <tt class="docutils literal"><span class="pre">//=</span></tt>, <tt class="docutils literal"><span class="pre">%=</span></tt>,
<tt class="docutils literal"><span class="pre">**=</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&amp;=</span></tt>, <tt class="docutils literal"><span class="pre">^=</span></tt>, <tt class="docutils literal"><span class="pre">|=</span></tt>).  These methods
should attempt to do the operation in-place (modifying <em>self</em>) and
return the result (which could be, but does not have to be,
<em>self</em>).  If a specific method is not defined, the augmented
assignment falls back to the normal methods.  For instance, to
execute the statement <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></tt>, where <em>x</em> is an instance of a
class that has an <tt class="docutils literal"><span class="pre">__iadd__()</span></tt> method, <tt class="docutils literal"><span class="pre">x.__iadd__(y)</span></tt> is
called.  If <em>x</em> is an instance of a class that does not define a
<tt class="docutils literal"><span class="pre">__iadd__()</span></tt> method, <tt class="docutils literal"><span class="pre">x.__add__(y)</span></tt> and <tt class="docutils literal"><span class="pre">y.__radd__(x)</span></tt> are
considered, as with the evaluation of <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt>.</blockquote>
<p>object.__neg__(self)
object.__pos__(self)
object.__abs__(self)
object.__invert__(self)</p>
<blockquote>
Called to implement the unary arithmetic operations (<tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">+</span></tt>,
<tt class="docutils literal"><span class="pre">abs()</span></tt> and <tt class="docutils literal"><span class="pre">~</span></tt>).</blockquote>
<p>object.__complex__(self)
object.__int__(self)
object.__long__(self)
object.__float__(self)</p>
<blockquote>
Called to implement the built-in functions <tt class="docutils literal"><span class="pre">complex()</span></tt>,
<tt class="docutils literal"><span class="pre">int()</span></tt>, <tt class="docutils literal"><span class="pre">long()</span></tt>, and <tt class="docutils literal"><span class="pre">float()</span></tt>.  Should return a value of
the appropriate type.</blockquote>
<p>object.__oct__(self)
object.__hex__(self)</p>
<blockquote>
Called to implement the built-in functions <tt class="docutils literal"><span class="pre">oct()</span></tt> and <tt class="docutils literal"><span class="pre">hex()</span></tt>.
Should return a string value.</blockquote>
<p>object.__index__(self)</p>
<blockquote>
<p>Called to implement <tt class="docutils literal"><span class="pre">operator.index()</span></tt>.  Also called whenever
Python needs an integer object (such as in slicing).  Must return
an integer (int or long).</p>
<p>New in version 2.5.</p>
</blockquote>
<p>object.__coerce__(self, other)</p>
<blockquote>
Called to implement &#8220;mixed-mode&#8221; numeric arithmetic.  Should either
return a 2-tuple containing <em>self</em> and <em>other</em> converted to a
common numeric type, or <tt class="xref docutils literal"><span class="pre">None</span></tt> if conversion is impossible.  When
the common type would be the type of <tt class="docutils literal"><span class="pre">other</span></tt>, it is sufficient to
return <tt class="xref docutils literal"><span class="pre">None</span></tt>, since the interpreter will also ask the other
object to attempt a coercion (but sometimes, if the implementation
of the other type cannot be changed, it is useful to do the
conversion to the other type here).  A return value of
<tt class="docutils literal"><span class="pre">NotImplemented</span></tt> is equivalent to returning <tt class="xref docutils literal"><span class="pre">None</span></tt>.</blockquote>
</div>
<div class="section" id="coercion-rules">
<h3>3.4.8. Coercion rules<a class="headerlink" href="#coercion-rules" title="Permalink to this headline">¶</a></h3>
<p>This section used to document the rules for coercion.  As the language
has evolved, the coercion rules have become hard to document
precisely; documenting what one version of one particular
implementation does is undesirable.  Instead, here are some informal
guidelines regarding coercion.  In Python 3.0, coercion will not be
supported.</p>
<ul>
<li><p class="first">If the left operand of a % operator is a string or Unicode object,
no coercion takes place and the string formatting operation is
invoked instead.</p>
</li>
<li><p class="first">It is no longer recommended to define a coercion operation. Mixed-
mode operations on types that don&#8217;t define coercion pass the
original arguments to the operation.</p>
</li>
<li><p class="first">New-style classes (those derived from <tt class="docutils literal"><span class="pre">object</span></tt>) never invoke the
<tt class="docutils literal"><span class="pre">__coerce__()</span></tt> method in response to a binary operator; the only
time <tt class="docutils literal"><span class="pre">__coerce__()</span></tt> is invoked is when the built-in function
<tt class="docutils literal"><span class="pre">coerce()</span></tt> is called.</p>
</li>
<li><p class="first">For most intents and purposes, an operator that returns
<tt class="docutils literal"><span class="pre">NotImplemented</span></tt> is treated the same as one that is not
implemented at all.</p>
</li>
<li><p class="first">Below, <tt class="docutils literal"><span class="pre">__op__()</span></tt> and <tt class="docutils literal"><span class="pre">__rop__()</span></tt> are used to signify the
generic method names corresponding to an operator; <tt class="docutils literal"><span class="pre">__iop__()</span></tt> is
used for the corresponding in-place operator.  For example, for the
operator &#8216;<tt class="docutils literal"><span class="pre">+</span></tt>&#8216;, <tt class="docutils literal"><span class="pre">__add__()</span></tt> and <tt class="docutils literal"><span class="pre">__radd__()</span></tt> are used for the
left and right variant of the binary operator, and <tt class="docutils literal"><span class="pre">__iadd__()</span></tt>
for the in-place variant.</p>
</li>
<li><p class="first">For objects <em>x</em> and <em>y</em>, first <tt class="docutils literal"><span class="pre">x.__op__(y)</span></tt> is tried.  If this is
not implemented or returns <tt class="docutils literal"><span class="pre">NotImplemented</span></tt>, <tt class="docutils literal"><span class="pre">y.__rop__(x)</span></tt> is
tried.  If this is also not implemented or returns
<tt class="docutils literal"><span class="pre">NotImplemented</span></tt>, a <tt class="docutils literal"><span class="pre">TypeError</span></tt> exception is raised.  But see
the following exception:</p>
</li>
<li><p class="first">Exception to the previous item: if the left operand is an instance
of a built-in type or a new-style class, and the right operand is an
instance of a proper subclass of that type or class and overrides
the base&#8217;s <tt class="docutils literal"><span class="pre">__rop__()</span></tt> method, the right operand&#8217;s <tt class="docutils literal"><span class="pre">__rop__()</span></tt>
method is tried <em>before</em> the left operand&#8217;s <tt class="docutils literal"><span class="pre">__op__()</span></tt> method.</p>
<p>This is done so that a subclass can completely override binary
operators. Otherwise, the left operand&#8217;s <tt class="docutils literal"><span class="pre">__op__()</span></tt> method would
always accept the right operand: when an instance of a given class
is expected, an instance of a subclass of that class is always
acceptable.</p>
</li>
<li><p class="first">When either operand type defines a coercion, this coercion is called
before that type&#8217;s <tt class="docutils literal"><span class="pre">__op__()</span></tt> or <tt class="docutils literal"><span class="pre">__rop__()</span></tt> method is called,
but no sooner.  If the coercion returns an object of a different
type for the operand whose coercion is invoked, part of the process
is redone using the new object.</p>
</li>
<li><p class="first">When an in-place operator (like &#8216;<tt class="docutils literal"><span class="pre">+=</span></tt>&#8216;) is used, if the left
operand implements <tt class="docutils literal"><span class="pre">__iop__()</span></tt>, it is invoked without any
coercion.  When the operation falls back to <tt class="docutils literal"><span class="pre">__op__()</span></tt> and/or
<tt class="docutils literal"><span class="pre">__rop__()</span></tt>, the normal coercion rules apply.</p>
</li>
<li><p class="first">In <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt>, if <em>x</em> is a sequence that implements sequence
concatenation, sequence concatenation is invoked.</p>
</li>
<li><p class="first">In <tt class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></tt>, if one operator is a sequence that implements sequence
repetition, and the other is an integer (<tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">long</span></tt>),
sequence repetition is invoked.</p>
</li>
<li><p class="first">Rich comparisons (implemented by methods <tt class="docutils literal"><span class="pre">__eq__()</span></tt> and so on)
never use coercion.  Three-way comparison (implemented by
<tt class="docutils literal"><span class="pre">__cmp__()</span></tt>) does use coercion under the same conditions as other
binary operations use it.</p>
</li>
<li><p class="first">In the current implementation, the built-in numeric types <tt class="docutils literal"><span class="pre">int</span></tt>,
<tt class="docutils literal"><span class="pre">long</span></tt> and <tt class="docutils literal"><span class="pre">float</span></tt> do not use coercion; the type <tt class="docutils literal"><span class="pre">complex</span></tt>
however does use coercion for binary operators and rich comparisons,
despite the above rules.  The difference can become apparent when
subclassing these types.  Over time, the type <tt class="docutils literal"><span class="pre">complex</span></tt> may be
fixed to avoid coercion. All these types implement a
<tt class="docutils literal"><span class="pre">__coerce__()</span></tt> method, for use by the built-in <tt class="docutils literal"><span class="pre">coerce()</span></tt>
function.</p>
</li>
</ul>
</div>
<div class="section" id="with-statement-context-managers">
<h3>3.4.9. With Statement Context Managers<a class="headerlink" href="#with-statement-context-managers" title="Permalink to this headline">¶</a></h3>
<p>New in version 2.5.</p>
<p>A <em>context manager</em> is an object that defines the runtime context to
be established when executing a <tt class="docutils literal"><span class="pre">with</span></tt> statement. The context
manager handles the entry into, and the exit from, the desired runtime
context for the execution of the block of code.  Context managers are
normally invoked using the <tt class="docutils literal"><span class="pre">with</span></tt> statement (described in section
<em>The with statement</em>), but can also be used by directly invoking their
methods.</p>
<p>Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.</p>
<p>For more information on context managers, see <em>Context Manager Types</em>.</p>
<p>object.__enter__(self)</p>
<blockquote>
Enter the runtime context related to this object. The <tt class="docutils literal"><span class="pre">with</span></tt>
statement will bind this method&#8217;s return value to the target(s)
specified in the <tt class="docutils literal"><span class="pre">as</span></tt> clause of the statement, if any.</blockquote>
<p>object.__exit__(self, exc_type, exc_value, traceback)</p>
<blockquote>
<p>Exit the runtime context related to this object. The parameters
describe the exception that caused the context to be exited. If the
context was exited without an exception, all three arguments will
be <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>If an exception is supplied, and the method wishes to suppress the
exception (i.e., prevent it from being propagated), it should
return a true value. Otherwise, the exception will be processed
normally upon exit from this method.</p>
<p>Note that <tt class="docutils literal"><span class="pre">__exit__()</span></tt> methods should not reraise the passed-in
exception; this is the caller&#8217;s responsibility.</p>
</blockquote>
<p>See also:</p>
<blockquote>
<dl class="docutils">
<dt><strong>PEP 0343</strong> - The &#8220;with&#8221; statement</dt>
<dd>The specification, background, and examples for the Python
<tt class="docutils literal"><span class="pre">with</span></tt> statement.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="special-method-lookup-for-old-style-classes">
<h3>3.4.10. Special method lookup for old-style classes<a class="headerlink" href="#special-method-lookup-for-old-style-classes" title="Permalink to this headline">¶</a></h3>
<p>For old-style classes, special methods are always looked up in exactly
the same way as any other method or attribute. This is the case
regardless of whether the method is being looked up explicitly as in
<tt class="docutils literal"><span class="pre">x.__getitem__(i)</span></tt> or implicitly as in <tt class="docutils literal"><span class="pre">x[i]</span></tt>.</p>
<p>This behaviour means that special methods may exhibit different
behaviour for different instances of a single old-style class if the
appropriate special attributes are set differently:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
</div>
<div class="section" id="special-method-lookup-for-new-style-classes">
<h3>3.4.11. Special method lookup for new-style classes<a class="headerlink" href="#special-method-lookup-for-new-style-classes" title="Permalink to this headline">¶</a></h3>
<p>For new-style classes, implicit invocations of special methods are
only guaranteed to work correctly if defined on an object&#8217;s type, not
in the object&#8217;s instance dictionary.  That behaviour is the reason why
the following code raises an exception (unlike the equivalent example
with old-style classes):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mf">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>The rationale behind this behaviour lies with a number of special
methods such as <tt class="docutils literal"><span class="pre">__hash__()</span></tt> and <tt class="docutils literal"><span class="pre">__repr__()</span></tt> that are implemented
by all objects, including type objects. If the implicit lookup of
these methods used the conventional lookup process, they would fail
when invoked on the type object itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">1</span> <span class="o">.</span><span class="n">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">&lt;module&gt;</span>
<span class="nc">TypeError</span>: <span class="n-Identifier">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>Incorrectly attempting to invoke an unbound method of a class in this
way is sometimes referred to as &#8216;metaclass confusion&#8217;, and is avoided
by bypassing the instance when looking up special methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="o">.</span><span class="n">__hash__</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses
the <tt class="docutils literal"><span class="pre">__getattribute__()</span></tt> method even of the object&#8217;s metaclass:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="s">&quot;Metaclass getattribute invoked&quot;</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">Meta</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mf">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span> <span class="s">&quot;Class getattribute invoked&quot;</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>                 <span class="c"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Bypassing the <tt class="docutils literal"><span class="pre">__getattribute__()</span></tt> machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method <em>must</em> be set on the class object
itself in order to be consistently invoked by the interpreter).</p>
<p>-[ Footnotes ]-</p>
<dl class="docutils">
<dt>[1] It <em>is</em> possible in some cases to change an object&#8217;s type, under</dt>
<dd>certain controlled conditions. It generally isn&#8217;t a good idea
though, since it can lead to some very strange behaviour if it is
handled incorrectly.</dd>
<dt>[2] A descriptor can define any combination of <tt class="docutils literal"><span class="pre">__get__()</span></tt>,</dt>
<dd><tt class="docutils literal"><span class="pre">__set__()</span></tt> and <tt class="docutils literal"><span class="pre">__delete__()</span></tt>.  If it does not define
<tt class="docutils literal"><span class="pre">__get__()</span></tt>, then accessing the attribute even on an instance
will return the descriptor object itself.  If the descriptor
defines <tt class="docutils literal"><span class="pre">__set__()</span></tt> and/or <tt class="docutils literal"><span class="pre">__delete__()</span></tt>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.</dd>
<dt>[3] For operands of the same type, it is assumed that if the non-</dt>
<dd>reflected method (such as <tt class="docutils literal"><span class="pre">__add__()</span></tt>) fails the operation is
not supported, which is why the reflected method is not called.</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>


      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Jython v2.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 2009, Jython Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
    </div>
  </body>
</html>