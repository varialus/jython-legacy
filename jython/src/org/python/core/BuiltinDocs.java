//generated by make_pydocs.py

package org.python.core;

public class BuiltinDocs {

    //Docs for <type 'str'>
    public final static String str___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String str___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String str___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String str___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String str___doc___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String str___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String str___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String str___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String str___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String str___getnewargs___doc = 
        "";

    public final static String str___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "               \n" + 
        "               Use of negative indices is not supported.";

    public final static String str___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String str___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String str___init___doc = 
        "x.__init__(...) initializes x; see x.__class__.__doc__ for signature";

    public final static String str___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String str___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String str___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String str___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String str___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String str___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String str___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String str___reduce___doc = 
        "helper for pickle";

    public final static String str___reduce_ex___doc = 
        "helper for pickle";

    public final static String str___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String str___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String str___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String str___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String str___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String str_capitalize_doc = 
        "S.capitalize() -> string\n" + 
        "\n" + 
        "Return a copy of the string S with only its first character\n" + 
        "capitalized.";

    public final static String str_center_doc = 
        "S.center(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S centered in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String str_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "string S[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String str_decode_doc = 
        "S.decode([encoding[,errors]]) -> object\n" + 
        "\n" + 
        "Decodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "as well as any other name registerd with codecs.register_error that is\n" + 
        "able to handle UnicodeDecodeErrors.";

    public final static String str_encode_doc = 
        "S.encode([encoding[,errors]]) -> object\n" + 
        "\n" + 
        "Encodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n" + 
        "'xmlcharrefreplace' as well as any other name registered with\n" + 
        "codecs.register_error that is able to handle UnicodeEncodeErrors.";

    public final static String str_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String str_expandtabs_doc = 
        "S.expandtabs([tabsize]) -> string\n" + 
        "\n" + 
        "Return a copy of S where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String str_find_doc = 
        "S.find(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_index_doc = 
        "S.index(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.find() but raise ValueError when the substring is not found.";

    public final static String str_isalnum_doc = 
        "S.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphanumeric\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isalpha_doc = 
        "S.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphabetic\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_isdigit_doc = 
        "S.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are digits\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_islower_doc = 
        "S.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are lowercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_isspace_doc = 
        "S.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are whitespace\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String str_istitle_doc = 
        "S.istitle() -> bool\n" + 
        "\n" + 
        "Return True if S is a titlecased string and there is at least one\n" + 
        "character in S, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String str_isupper_doc = 
        "S.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are uppercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String str_join_doc = 
        "S.join(sequence) -> string\n" + 
        "\n" + 
        "Return a string which is the concatenation of the strings in the\n" + 
        "sequence.  The separator between elements is S.";

    public final static String str_ljust_doc = 
        "S.ljust(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String str_lower_doc = 
        "S.lower() -> string\n" + 
        "\n" + 
        "Return a copy of the string S converted to lowercase.";

    public final static String str_lstrip_doc = 
        "S.lstrip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_partition_doc = 
        "S.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Searches for the separator sep in S, and returns the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, returns S and two empty strings.";

    public final static String str_replace_doc = 
        "S.replace (old, new[, count]) -> string\n" + 
        "\n" + 
        "Return a copy of string S with all occurrences of substring\n" + 
        "old replaced by new.  If the optional argument count is\n" + 
        "given, only the first count occurrences are replaced.";

    public final static String str_rfind_doc = 
        "S.rfind(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_rindex_doc = 
        "S.rindex(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.rfind() but raise ValueError when the substring is not found.";

    public final static String str_rjust_doc = 
        "S.rjust(width[, fillchar]) -> string\n" + 
        "\n" + 
        "Return S right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String str_rpartition_doc = 
        "S.rpartition(sep) -> (tail, sep, head)\n" + 
        "\n" + 
        "Searches for the separator sep in S, starting at the end of S, and returns\n" + 
        "the part before it, the separator itself, and the part after it.  If the\n" + 
        "separator is not found, returns two empty strings and S.";

    public final static String str_rsplit_doc = 
        "S.rsplit([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in the string S, using sep as the\n" + 
        "delimiter string, starting at the end of the string and working\n" + 
        "to the front.  If maxsplit is given, at most maxsplit splits are\n" + 
        "done. If sep is not specified or is None, any whitespace string\n" + 
        "is a separator.";

    public final static String str_rstrip_doc = 
        "S.rstrip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with trailing whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_split_doc = 
        "S.split([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in the string S, using sep as the\n" + 
        "delimiter string.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified or is None, any\n" + 
        "whitespace string is a separator.";

    public final static String str_splitlines_doc = 
        "S.splitlines([keepends]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the lines in S, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String str_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String str_strip_doc = 
        "S.strip([chars]) -> string or unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading and trailing\n" + 
        "whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is unicode, S will be converted to unicode before stripping";

    public final static String str_swapcase_doc = 
        "S.swapcase() -> string\n" + 
        "\n" + 
        "Return a copy of the string S with uppercase characters\n" + 
        "converted to lowercase and vice versa.";

    public final static String str_title_doc = 
        "S.title() -> string\n" + 
        "\n" + 
        "Return a titlecased version of S, i.e. words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String str_translate_doc = 
        "S.translate(table [,deletechars]) -> string\n" + 
        "\n" + 
        "Return a copy of the string S, where all characters occurring\n" + 
        "in the optional argument deletechars are removed, and the\n" + 
        "remaining characters have been mapped through the given\n" + 
        "translation table, which must be a string of length 256.";

    public final static String str_upper_doc = 
        "S.upper() -> string\n" + 
        "\n" + 
        "Return a copy of the string S converted to uppercase.";

    public final static String str_zfill_doc = 
        "S.zfill(width) -> string\n" + 
        "\n" + 
        "Pad a numeric string S with zeros on the left, to fill a field\n" + 
        "of the specified width.  The string S is never truncated.";

    //Docs for <type 'unicode'>
    public final static String unicode___add___doc = 
        "x.__add__(y) <==> x+y";

    public final static String unicode___class___doc = 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String unicode___contains___doc = 
        "x.__contains__(y) <==> y in x";

    public final static String unicode___delattr___doc = 
        "x.__delattr__('name') <==> del x.name";

    public final static String unicode___doc___doc = 
        "str(object) -> string\n" + 
        "\n" + 
        "Return a nice string representation of the object.\n" + 
        "If the argument is a string, the return value is the same object.";

    public final static String unicode___eq___doc = 
        "x.__eq__(y) <==> x==y";

    public final static String unicode___ge___doc = 
        "x.__ge__(y) <==> x>=y";

    public final static String unicode___getattribute___doc = 
        "x.__getattribute__('name') <==> x.name";

    public final static String unicode___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String unicode___getnewargs___doc = 
        "";

    public final static String unicode___getslice___doc = 
        "x.__getslice__(i, j) <==> x[i:j]\n" + 
        "               \n" + 
        "               Use of negative indices is not supported.";

    public final static String unicode___gt___doc = 
        "x.__gt__(y) <==> x>y";

    public final static String unicode___hash___doc = 
        "x.__hash__() <==> hash(x)";

    public final static String unicode___init___doc = 
        "x.__init__(...) initializes x; see x.__class__.__doc__ for signature";

    public final static String unicode___le___doc = 
        "x.__le__(y) <==> x<=y";

    public final static String unicode___len___doc = 
        "x.__len__() <==> len(x)";

    public final static String unicode___lt___doc = 
        "x.__lt__(y) <==> x<y";

    public final static String unicode___mod___doc = 
        "x.__mod__(y) <==> x%y";

    public final static String unicode___mul___doc = 
        "x.__mul__(n) <==> x*n";

    public final static String unicode___ne___doc = 
        "x.__ne__(y) <==> x!=y";

    public final static String unicode___new___doc = 
        "T.__new__(S, ...) -> a new object with type S, a subtype of T";

    public final static String unicode___reduce___doc = 
        "helper for pickle";

    public final static String unicode___reduce_ex___doc = 
        "helper for pickle";

    public final static String unicode___repr___doc = 
        "x.__repr__() <==> repr(x)";

    public final static String unicode___rmod___doc = 
        "x.__rmod__(y) <==> y%x";

    public final static String unicode___rmul___doc = 
        "x.__rmul__(n) <==> n*x";

    public final static String unicode___setattr___doc = 
        "x.__setattr__('name', value) <==> x.name = value";

    public final static String unicode___str___doc = 
        "x.__str__() <==> str(x)";

    public final static String unicode_capitalize_doc = 
        "S.capitalize() -> unicode\n" + 
        "\n" + 
        "Return a capitalized version of S, i.e. make the first character\n" + 
        "have upper case.";

    public final static String unicode_center_doc = 
        "S.center(width[, fillchar]) -> unicode\n" + 
        "\n" + 
        "Return S centered in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String unicode_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "Unicode string S[start:end].  Optional arguments start and end are\n" + 
        "interpreted as in slice notation.";

    public final static String unicode_decode_doc = 
        "S.decode([encoding[,errors]]) -> string or unicode\n" + 
        "\n" + 
        "Decodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "as well as any other name registerd with codecs.register_error that is\n" + 
        "able to handle UnicodeDecodeErrors.";

    public final static String unicode_encode_doc = 
        "S.encode([encoding[,errors]]) -> string or unicode\n" + 
        "\n" + 
        "Encodes S using the codec registered for encoding. encoding defaults\n" + 
        "to the default encoding. errors may be given to set a different error\n" + 
        "handling scheme. Default is 'strict' meaning that encoding errors raise\n" + 
        "a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n" + 
        "'xmlcharrefreplace' as well as any other name registered with\n" + 
        "codecs.register_error that can handle UnicodeEncodeErrors.";

    public final static String unicode_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String unicode_expandtabs_doc = 
        "S.expandtabs([tabsize]) -> unicode\n" + 
        "\n" + 
        "Return a copy of S where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String unicode_find_doc = 
        "S.find(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String unicode_index_doc = 
        "S.index(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.find() but raise ValueError when the substring is not found.";

    public final static String unicode_isalnum_doc = 
        "S.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphanumeric\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_isalpha_doc = 
        "S.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are alphabetic\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_isdecimal_doc = 
        "S.isdecimal() -> bool\n" + 
        "\n" + 
        "Return True if there are only decimal characters in S,\n" + 
        "False otherwise.";

    public final static String unicode_isdigit_doc = 
        "S.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are digits\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_islower_doc = 
        "S.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are lowercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String unicode_isnumeric_doc = 
        "S.isnumeric() -> bool\n" + 
        "\n" + 
        "Return True if there are only numeric characters in S,\n" + 
        "False otherwise.";

    public final static String unicode_isspace_doc = 
        "S.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in S are whitespace\n" + 
        "and there is at least one character in S, False otherwise.";

    public final static String unicode_istitle_doc = 
        "S.istitle() -> bool\n" + 
        "\n" + 
        "Return True if S is a titlecased string and there is at least one\n" + 
        "character in S, i.e. upper- and titlecase characters may only\n" + 
        "follow uncased characters and lowercase characters only cased ones.\n" + 
        "Return False otherwise.";

    public final static String unicode_isupper_doc = 
        "S.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in S are uppercase and there is\n" + 
        "at least one cased character in S, False otherwise.";

    public final static String unicode_join_doc = 
        "S.join(sequence) -> unicode\n" + 
        "\n" + 
        "Return a string which is the concatenation of the strings in the\n" + 
        "sequence.  The separator between elements is S.";

    public final static String unicode_ljust_doc = 
        "S.ljust(width[, fillchar]) -> int\n" + 
        "\n" + 
        "Return S left justified in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String unicode_lower_doc = 
        "S.lower() -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S converted to lowercase.";

    public final static String unicode_lstrip_doc = 
        "S.lstrip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_partition_doc = 
        "S.partition(sep) -> (head, sep, tail)\n" + 
        "\n" + 
        "Searches for the separator sep in S, and returns the part before it,\n" + 
        "the separator itself, and the part after it.  If the separator is not\n" + 
        "found, returns S and two empty strings.";

    public final static String unicode_replace_doc = 
        "S.replace (old, new[, maxsplit]) -> unicode\n" + 
        "\n" + 
        "Return a copy of S with all occurrences of substring\n" + 
        "old replaced by new.  If the optional argument maxsplit is\n" + 
        "given, only the first maxsplit occurrences are replaced.";

    public final static String unicode_rfind_doc = 
        "S.rfind(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within s[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String unicode_rindex_doc = 
        "S.rindex(sub [,start [,end]]) -> int\n" + 
        "\n" + 
        "Like S.rfind() but raise ValueError when the substring is not found.";

    public final static String unicode_rjust_doc = 
        "S.rjust(width[, fillchar]) -> unicode\n" + 
        "\n" + 
        "Return S right justified in a Unicode string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String unicode_rpartition_doc = 
        "S.rpartition(sep) -> (tail, sep, head)\n" + 
        "\n" + 
        "Searches for the separator sep in S, starting at the end of S, and returns\n" + 
        "the part before it, the separator itself, and the part after it.  If the\n" + 
        "separator is not found, returns two empty strings and S.";

    public final static String unicode_rsplit_doc = 
        "S.rsplit([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string, starting at the end of the string and\n" + 
        "working to the front.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified, any whitespace string\n" + 
        "is a separator.";

    public final static String unicode_rstrip_doc = 
        "S.rstrip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with trailing whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_split_doc = 
        "S.split([sep [,maxsplit]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the words in S, using sep as the\n" + 
        "delimiter string.  If maxsplit is given, at most maxsplit\n" + 
        "splits are done. If sep is not specified or is None,\n" + 
        "any whitespace string is a separator.";

    public final static String unicode_splitlines_doc = 
        "S.splitlines([keepends]]) -> list of strings\n" + 
        "\n" + 
        "Return a list of the lines in S, breaking at line boundaries.\n" + 
        "Line breaks are not included in the resulting list unless keepends\n" + 
        "is given and true.";

    public final static String unicode_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String unicode_strip_doc = 
        "S.strip([chars]) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S with leading and trailing\n" + 
        "whitespace removed.\n" + 
        "If chars is given and not None, remove characters in chars instead.\n" + 
        "If chars is a str, it will be converted to unicode before stripping";

    public final static String unicode_swapcase_doc = 
        "S.swapcase() -> unicode\n" + 
        "\n" + 
        "Return a copy of S with uppercase characters converted to lowercase\n" + 
        "and vice versa.";

    public final static String unicode_title_doc = 
        "S.title() -> unicode\n" + 
        "\n" + 
        "Return a titlecased version of S, i.e. words start with title case\n" + 
        "characters, all remaining cased characters have lower case.";

    public final static String unicode_translate_doc = 
        "S.translate(table) -> unicode\n" + 
        "\n" + 
        "Return a copy of the string S, where all characters have been mapped\n" + 
        "through the given translation table, which must be a mapping of\n" + 
        "Unicode ordinals to Unicode ordinals, Unicode strings or None.\n" + 
        "Unmapped characters are left untouched. Characters mapped to None\n" + 
        "are deleted.";

    public final static String unicode_upper_doc = 
        "S.upper() -> unicode\n" + 
        "\n" + 
        "Return a copy of S converted to uppercase.";

    public final static String unicode_zfill_doc = 
        "S.zfill(width) -> unicode\n" + 
        "\n" + 
        "Pad a numeric string x with zeros on the left, to fill a field\n" + 
        "of the specified width. The string x is never truncated.";

}
